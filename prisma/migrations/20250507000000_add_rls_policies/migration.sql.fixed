-- Enable RLS on tables
ALTER TABLE "Booking" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "Payment" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "Customer" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "Appointment" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "Note" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "TattooDesign" ENABLE ROW LEVEL SECURITY;

-- Create admin check function
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN (
    SELECT EXISTS (
      SELECT 1 FROM auth.users
      WHERE auth.uid() = id
      AND user_metadata->>'role' = 'admin'
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create client check function
CREATE OR REPLACE FUNCTION is_client()
RETURNS BOOLEAN AS $$
BEGIN
  RETURN (
    SELECT EXISTS (
      SELECT 1 FROM auth.users
      WHERE auth.uid() = id
      AND (user_metadata->>'role' IS NULL OR user_metadata->>'role' = 'client')
    )
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- RLS policies for admin access
CREATE POLICY "Admins can do anything with all tables" 
ON "Booking" FOR ALL 
USING (is_admin());

CREATE POLICY "Admins can do anything with all tables" 
ON "Payment" FOR ALL 
USING (is_admin());

CREATE POLICY "Admins can do anything with all tables" 
ON "Customer" FOR ALL 
USING (is_admin());

CREATE POLICY "Admins can do anything with all tables" 
ON "Appointment" FOR ALL 
USING (is_admin());

CREATE POLICY "Admins can do anything with all tables" 
ON "Note" FOR ALL 
USING (is_admin());

CREATE POLICY "Admins can do anything with all tables" 
ON "TattooDesign" FOR ALL 
USING (is_admin());

-- RLS policies for client access
CREATE POLICY "Clients can only view their own data" 
ON "Booking" FOR SELECT 
USING (email = auth.jwt()->>'email');

CREATE POLICY "Clients can only view their own data" 
ON "Payment" FOR SELECT 
USING ("customerEmail" = auth.jwt()->>'email');

CREATE POLICY "Clients can only view their own data" 
ON "Appointment" FOR SELECT 
USING ((SELECT email FROM "Customer" WHERE id = "customerId") = auth.jwt()->>'email');

CREATE POLICY "Clients can only view their own data" 
ON "TattooDesign" FOR SELECT 
USING ((SELECT email FROM "Customer" WHERE id = "customerId") = auth.jwt()->>'email');

-- Function to get available time slots
CREATE OR REPLACE FUNCTION get_available_slots(
  date_to_check DATE,
  duration_minutes INTEGER DEFAULT 60
) RETURNS JSONB
LANGUAGE plpgsql SECURITY DEFINER
AS $$
DECLARE
  start_hour INTEGER := 9; -- 9 AM
  end_hour INTEGER := 18;  -- 6 PM
  slot_interval INTERVAL := (duration_minutes || ' minutes')::INTERVAL;
  current_slot TIMESTAMP;
  available_slots JSONB := '[]'::JSONB;
  is_available BOOLEAN;
BEGIN
  -- Loop through each hour of the day
  FOR hour IN start_hour..end_hour-1 LOOP
    -- Create timestamp for current slot
    current_slot := (date_to_check + (hour || ' hours')::INTERVAL)::TIMESTAMP;
    
    -- Check if slot is available
    SELECT COUNT(*) = 0 INTO is_available
    FROM "Appointment"
    WHERE tsrange(current_slot, current_slot + slot_interval) && 
          tsrange("startDate", "endDate")
    AND status <> 'cancelled';
    
    -- Add available slot to result
    IF is_available THEN
      available_slots := available_slots || jsonb_build_object(
        'start_time', current_slot,
        'end_time', current_slot + slot_interval
      );
    END IF;
  END LOOP;
  
  RETURN jsonb_build_object('available_slots', available_slots);
END;
$$;