import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { router, adminProcedure } from '../procedures';
import { prisma } from '@/lib/db/prisma';
import { Prisma, PaymentStatus } from '@prisma/client';
// Types are imported directly from @prisma/client as needed
import { logger } from '@/lib/logger';

/**
 * Admin-only payment router for business intelligence and dashboard features.
 * Customer-facing payment operations are handled by Cal.com.
 */
export const paymentsRouter = router({
  /**
   * Admin: Get payment by ID with full details
   */
  getPaymentById: adminProcedure.input(z.object({ id: z.string() })).query(async ({ input }) => {
    try {
      // Now using actual Payment model with relations
      const payment = await prisma.payment.findUnique({
        where: { id: input.id },
        include: {
          customer: true,
          booking: true,
          appointment: true,
        },
      });

      if (!payment) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Payment not found',
        });
      }

      return payment;
    } catch (error) {
      if (error instanceof TRPCError) {
        throw error;
      }
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Error fetching payment',
        cause: error,
      });
    }
  }),

  /**
   * Admin: Get all payments with filtering
   */
  getAllPayments: adminProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).default(50),
        cursor: z.string().nullish(),
        status: z.nativeEnum(PaymentStatus).optional(),
        customerId: z.string().optional(),
        startDate: z.date().optional(),
        endDate: z.date().optional(),
      })
    )
    .query(async ({ input }) => {
      try {
        const where: Prisma.PaymentWhereInput = {};

        if (input.status) {
          where.status = input.status;
        }

        if (input.customerId) {
          where.customer = {
            id: input.customerId
          };
        }

        if (input.startDate || input.endDate) {
          const dateFilter: Prisma.DateTimeFilter = {};
          if (input.startDate) {
            dateFilter.gte = input.startDate;
          }
          if (input.endDate) {
            dateFilter.lte = input.endDate;
          }
          where.createdAt = dateFilter;
        }

        const payments = await prisma.payment.findMany({
          where,
          include: {
            customer: {
              select: {
                email: true,
                firstName: true,
                lastName: true,
              },
            },
          },
          orderBy: {
            createdAt: 'desc',
          },
          take: input.limit + 1,
          ...(input.cursor && { cursor: { id: input.cursor } }),
        });

        let nextCursor: string | undefined;
        if (payments.length > input.limit) {
          const nextItem = payments.pop();
          nextCursor = nextItem?.id;
        }

        // Transform payments for response
        const paymentList = payments.map(payment => ({
          id: payment.id,
          amount: payment.amount,
          status: payment.status,
          customerEmail: (payment as any).customer?.email || '',
          customerName: (payment as any).customer ? `${(payment as any).customer.firstName} ${(payment as any).customer.lastName}` : '',
          createdAt: payment.createdAt,
          updatedAt: payment.updatedAt,
        }));

        return {
          items: paymentList,
          nextCursor,
        };
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Error fetching payments',
          cause: error,
        });
      }
    }),

  /**
   * Get payment statistics for admin dashboard
   */
  getPaymentStats: adminProcedure
    .input(
      z.object({
        startDate: z.date().optional(),
        endDate: z.date().optional(),
        timeRange: z.enum(['week', 'month', 'year']).optional(),
      })
    )
    .query(async ({ input }) => {
      try {
        const where: Prisma.BookingWhereInput = {};

        // Handle time range if provided
        if (input.timeRange) {
          const now = new Date();
          let startDate: Date;
          
          switch (input.timeRange) {
            case 'week':
              startDate = new Date(now);
              startDate.setDate(now.getDate() - 7);
              break;
            case 'month':
              startDate = new Date(now);
              startDate.setMonth(now.getMonth() - 1);
              break;
            case 'year':
              startDate = new Date(now);
              startDate.setFullYear(now.getFullYear() - 1);
              break;
          }
          
          where.createdAt = {
            gte: startDate,
            lte: now,
          };
        } else if (input.startDate || input.endDate) {
          where.createdAt = {};
          if (input.startDate) {
            where.createdAt.gte = input.startDate;
          }
          if (input.endDate) {
            where.createdAt.lte = input.endDate;
          }
        }

        const [totalRevenue, totalPayments, paymentsByStatus, averagePayment, topServices] = await Promise.all([
          // Total revenue (completed bookings only)
          prisma.booking.aggregate({
            where: { ...where, status: PaymentStatus.COMPLETED },
            _sum: { totalCost: true },
          }),

          // Total number of bookings/payments
          prisma.booking.count({ where }),

          // Bookings by status
          prisma.booking.groupBy({
            by: ['status'],
            where,
            _count: { id: true },
            _sum: { totalCost: true },
          }),

          // Average booking amount
          prisma.booking.aggregate({
            where,
            _avg: { totalCost: true },
          }),

          // Top services by revenue
          prisma.booking.groupBy({
            by: ['tattooType'],
            where: {
              createdAt: where.createdAt,
            },
            _count: { id: true },
            _sum: { totalCost: true },
          }),
        ]);

        // Calculate additional metrics
        const paidAmount = paymentsByStatus.find(p => p.status === PaymentStatus.COMPLETED)?._sum.totalCost ?? 0;
        const pendingAmount = paymentsByStatus.find(p => p.status === PaymentStatus.PENDING)?._sum.totalCost ?? 0;
        const failedAmount = paymentsByStatus.find(p => p.status === PaymentStatus.FAILED)?._sum.totalCost ?? 0;
        
        const paidCount = paymentsByStatus.find(p => p.status === PaymentStatus.COMPLETED)?._count.id ?? 0;
        const pendingCount = paymentsByStatus.find(p => p.status === PaymentStatus.PENDING)?._count.id ?? 0;
        const failedCount = paymentsByStatus.find(p => p.status === PaymentStatus.FAILED)?._count.id ?? 0;
        
        const total = paidAmount + pendingAmount + failedAmount;
        
        return {
          totalRevenue: totalRevenue._sum.totalCost ?? 0,
          totalPayments,
          averagePayment: averagePayment._avg.totalCost ?? 0,
          paidAmount,
          pendingAmount,
          failedAmount,
          paidCount,
          pendingCount,
          failedCount,
          paidPercentage: total > 0 ? (paidAmount / total) * 100 : 0,
          pendingPercentage: total > 0 ? (pendingAmount / total) * 100 : 0,
          failedPercentage: total > 0 ? (failedAmount / total) * 100 : 0,
          revenueChange: 10, // Placeholder - would calculate real trend
          paymentsByStatus: paymentsByStatus.map((item) => ({
            status: item.status,
            count: item._count.id,
            totalAmount: item._sum.totalCost ?? 0,
          })),
          paymentMethods: [
            { type: 'Card', count: paidCount, amount: paidAmount },
          ], // Simplified since payment method isn't in booking schema
          topServices: topServices.slice(0, 5).map((service) => ({
            name: service.tattooType,
            bookings: service._count.id,
            revenue: service._sum.totalCost ?? 0,
          })),
        };
      } catch (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Error fetching payment statistics',
          cause: error,
        });
      }
    }),

  /**
   * Get payments for the payments page table
   */
  getPayments: adminProcedure
    .input(
      z.object({
        timeRange: z.enum(['week', 'month', 'year']).optional(),
        status: z.string().optional(),
      })
    )
    .query(async ({ input }) => {
      try {
        // Generate mock data for now - replace with real Cal.com integration
        const mockPayments = [];
        const statuses = ['paid', 'pending', 'failed', 'refunded'];
        const services = ['Tattoo Consultation', 'Small Tattoo Session', 'Large Tattoo Session', 'Cover-up Session'];
        const methods = ['Card', 'PayPal', 'Cash', 'Bank Transfer'];
        
        // Generate 20 mock payments
        for (let i = 0; i < 20; i++) {
          const date = new Date();
          date.setDate(date.getDate() - Math.floor(Math.random() * 30));
          
          mockPayments.push({
            id: `payment-${i}`,
            bookingId: `booking-${i}`,
            amount: Math.floor(Math.random() * 500) + 100,
            currency: 'USD',
            status: statuses[Math.floor(Math.random() * statuses.length)],
            paymentMethod: methods[Math.floor(Math.random() * methods.length)],
            customerName: `Customer ${i + 1}`,
            customerEmail: `customer${i + 1}@example.com`,
            serviceName: services[Math.floor(Math.random() * services.length)],
            createdAt: date.toISOString(),
            paidAt: date.toISOString(),
          });
        }
        
        // Filter by status if provided
        let filtered = mockPayments;
        if (input.status && input.status !== 'all') {
          filtered = mockPayments.filter(p => p.status === input.status);
        }
        
        // Filter by time range
        if (input.timeRange) {
          const now = new Date();
          let startDate: Date;
          
          switch (input.timeRange) {
            case 'week':
              startDate = new Date(now);
              startDate.setDate(now.getDate() - 7);
              break;
            case 'month':
              startDate = new Date(now);
              startDate.setMonth(now.getMonth() - 1);
              break;
            case 'year':
              startDate = new Date(now);
              startDate.setFullYear(now.getFullYear() - 1);
              break;
          }
          
          filtered = filtered.filter(p => new Date(p.createdAt) >= startDate);
        }
        
        return filtered;
      } catch (error) {
        logger.error('Error fetching payments:', error);
        return [];
      }
    }),
});/**
 * Gallery Router
 *
 * This router handles all gallery-related API endpoints,
 * including retrieving tattoo designs and portfolio items.
 */
import { z } from 'zod';
import { logger } from '@/lib/logger';
import { publicProcedure, protectedProcedure, adminProcedure, router } from '../procedures';
import { TRPCError } from '@trpc/server';
import { Prisma } from '@prisma/client';
import { randomUUID } from 'node:crypto';


// Validation schema for creating a design
export const designValidator = z.object({
  name: z.string().min(1, 'Name is required'),
  description: z.string().optional(),
  image: z.string().min(1, 'Image is required'),
  designType: z.string().optional(),
  size: z.string().optional(),
  isApproved: z.boolean().default(false),
  customerId: z.string().optional(),
});

// Export the gallery router with all procedures
export const galleryRouter = router({
  // Get all designs (admin only)
  getAll: adminProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).default(50),
        cursor: z.string().optional(),
        includeUnapproved: z.boolean().default(true),
      })
    )
    .query(async ({ input, ctx }) => {
      const { limit, cursor, includeUnapproved } = input;

      // Build the where clause
      const where: Prisma.TattooDesignWhereInput = {};

      // Only include approved designs if specified
      if (!includeUnapproved) {
        where.isApproved = true;
      }

      // Get designs with pagination
      const designs = await ctx.db.tattooDesign.findMany({
        where,
        take: limit + 1,
        cursor: cursor ? { id: cursor } : undefined,
        orderBy: { createdAt: 'desc' },
        include: {
          artist: {
            select: {
              id: true,
              name: true,
            },
          },
          customer: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
            },
          },
        },
      });

      let nextCursor: typeof cursor | undefined = undefined;
      if (designs.length > limit) {
        const nextItem = designs.pop();
        nextCursor = nextItem!.id;
      }

      return {
        items: designs,
        nextCursor,
      };
    }),

  // Get all approved designs for public gallery
  getPublicDesigns: publicProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).default(20),
        cursor: z.number().optional(),
        designType: z.string().optional(),
      })
    )
    .query(async ({ input, ctx }) => {
      const { limit, cursor, designType } = input;

      // Build the where clause
      const where: Prisma.TattooDesignWhereInput = {
        isApproved: true,
      };

      // Add designType filter if provided
      if (designType) {
        where.designType = designType;
      }

      // Get total count
      const totalCount = await ctx.db.tattooDesign.count({ where });

      // Get designs with proper cursor handling for Prisma
      // Build the query options separately to handle conditional cursor
      const queryOptions: Prisma.TattooDesignFindManyArgs = {
        where,
        take: limit + 1, // take an extra item to determine if there are more
        orderBy: { createdAt: 'desc' }
        // No relationships in current schema
      };

      // Only add cursor if it's provided
      if (cursor) {
        queryOptions.cursor = { id: String(cursor) };
      }

      // Execute the query with proper typing
      const designs = await ctx.db.tattooDesign.findMany(queryOptions);

      // Check if there are more items
      let nextCursor: typeof cursor | null = null;
      if (designs.length > limit) {
        const nextItem = designs.pop();
        nextCursor = nextItem ? parseInt(nextItem.id) : null;
      }

      return {
        designs,
        nextCursor,
        totalCount,
      };
    }),

  // Get design by ID
  getDesignById: publicProcedure
    .input(z.object({ id: z.string() }))
    .query(async ({ input, ctx }) => {
      const design = await ctx.db.tattooDesign.findUnique({
        where: { id: input.id }
        // No relationships in current schema
      });

      if (!design) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: `Design with ID ${input.id} not found`,
        });
      }

      // Only allow access to non-approved designs for authenticated users
      if (!design.isApproved && !ctx.userId) {
        throw new TRPCError({
          code: 'FORBIDDEN',
          message: 'You do not have permission to view this design',
        });
      }

      return design;
    }),

  // Create a new design (protected - must be logged in)
  create: protectedProcedure.input(designValidator).mutation(async ({ input, ctx }) => {
    void logger.info('tRPC gallery.create input received', {
      input: JSON.stringify(input, null, 2),
      validationResult: designValidator.safeParse(input)
    });

    try {
      // Create the design - artist already exists in database
      const designData = {
        id: randomUUID(),
        name: input.name,
        description: input.description ?? null,
        fileUrl: input.image,
        thumbnailUrl: input.image,
        designType: input.designType ?? null,
        size: input.size ?? null,
        isApproved: input.isApproved ?? false,
        artistId: 'fernando-govea',
        updatedAt: new Date(),
      };

      const design = await ctx.db.tattooDesign.create({
        data: designData,
        select: {
          id: true,
          name: true,
          description: true,
          fileUrl: true,
          thumbnailUrl: true,
          designType: true,
          size: true,
          isApproved: true,
          createdAt: true,
          updatedAt: true,
        },
      });

      return design;
    } catch (error) {
      // Handle Prisma errors
      if (error instanceof Prisma.PrismaClientKnownRequestError) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to create design: ${error.message}`,
          cause: error,
        });
      }
      throw error;
    }
  }),

  // Update a design
  update: protectedProcedure
    .input(
      z.object({
        id: z.string(),
        name: z.string().min(2).optional(),
        description: z.string().optional(),
        image: z.string().optional(),
        designType: z.string().optional(),
        size: z.string().optional(),
        isApproved: z.boolean().optional(),
      })
    )
    .mutation(async ({ input, ctx }) => {
      const { id, ...data } = input;

      try {
        // Find the design first
        const existingDesign = await ctx.db.tattooDesign.findUnique({
          where: { id }
          // No Artist relationship in current schema
        });

        if (!existingDesign) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Design with ID ${id} not found`,
          });
        }

        // Check permissions - only authenticated users can update
        if (!ctx.userId) {
          throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'You do not have permission to update this design',
          });
        }

        // Convert input data to standard Prisma update format
        const updateData: Prisma.TattooDesignUpdateInput = {
          updatedAt: new Date(),
        };

        // Only include fields that are defined (not undefined)
        if (data.name !== undefined) updateData.name = data.name;
        if (data.description !== undefined) updateData.description = data.description;
        if (data.image !== undefined) {
          updateData.fileUrl = data.image;
          updateData.thumbnailUrl = data.image; // Auto-update thumbnail to same as fileUrl
        }
        if (data.designType !== undefined) updateData.designType = data.designType;
        if (data.size !== undefined) updateData.size = data.size;
        if (data.isApproved !== undefined) updateData.isApproved = data.isApproved;

        // Update the design
        const updatedDesign = await ctx.db.tattooDesign.update({
          where: { id },
          data: updateData,
          select: {
            id: true,
            name: true,
            description: true,
            fileUrl: true,
            thumbnailUrl: true,
            designType: true,
            size: true,
            isApproved: true,
            createdAt: true,
            updatedAt: true,
          },
        });

        return updatedDesign;
      } catch (error) {
        // Handle Prisma errors
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to update design: ${error.message}`,
            cause: error,
          });
        }
        throw error;
      }
    }),

  // Delete a design
  delete: protectedProcedure
    .input(z.object({ id: z.string() }))
    .mutation(async ({ input, ctx }) => {
      try {
        // Find the design first
        const existingDesign = await ctx.db.tattooDesign.findUnique({
          where: { id: input.id }
        });

        if (!existingDesign) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Design with ID ${input.id} not found`,
          });
        }

        // Check permissions - only authenticated users can delete
        if (!ctx.userId) {
          throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'You do not have permission to delete this design',
          });
        }

        // Delete the design
        await ctx.db.tattooDesign.delete({
          where: { id: input.id },
        });

        return { success: true };
      } catch (error) {
        // Handle Prisma errors
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to delete design: ${error.message}`,
            cause: error,
          });
        }
        throw error;
      }
    }),

  // Get design types for filtering
  getDesignTypes: publicProcedure.query(async ({ ctx }) => {
    // Get unique design types from the database
    const designs = await ctx.db.tattooDesign.findMany({
      where: { designType: { not: null } },
      select: { designType: true },
      distinct: ['designType'],
    });

    // Extract unique design types and filter out null/undefined values
    const designTypes = designs
      .map((design: { designType: string | null }) => design.designType)
      .filter((type): type is string => typeof type === 'string' && type !== '');

    return designTypes;
  }),

  // Get gallery stats for dashboard
  getStats: adminProcedure.query(async ({ ctx }) => {
    const totalDesigns = await ctx.db.tattooDesign.count();
    const approvedDesigns = await ctx.db.tattooDesign.count({
      where: { isApproved: true },
    });
    const pendingDesigns = await ctx.db.tattooDesign.count({
      where: { isApproved: false },
    });

    return {
      totalDesigns,
      approvedDesigns,
      pendingDesigns,
    };
  }),
});/**
 * Admin Notes Router
 *
 * This router handles all note-related admin operations,
 * including creating, updating, and retrieving customer notes.
 */
import { adminProcedure, router } from '../../procedures';
import { TRPCError } from '@trpc/server';
import { Prisma, NoteType } from '@prisma/client';
import { z } from 'zod';

// Note schemas using Zod for validation
const CreateNoteSchema = z.object({
  content: z.string().min(1, 'Note content is required'),
  type: z.nativeEnum(NoteType),
  customerId: z.string().uuid(),
  isPrivate: z.boolean().default(false),
  tags: z.array(z.string()).default([]),
  pinned: z.boolean().default(false),
});

const UpdateNoteSchema = z.object({
  id: z.string().uuid(),
  content: z.string().min(1).optional(),
  type: z.nativeEnum(NoteType).optional(),
  isPrivate: z.boolean().optional(),
  tags: z.array(z.string()).optional(),
  pinned: z.boolean().optional(),
});

const DeleteNoteSchema = z.object({
  id: z.string().uuid(),
});

const GetNotesByCustomerSchema = z.object({
  customerId: z.string().uuid(),
  limit: z.number().min(1).max(100).default(50),
  cursor: z.string().optional(),
  type: z.nativeEnum(NoteType).optional(),
  pinnedOnly: z.boolean().optional(),
});

const PinNoteSchema = z.object({
  id: z.string().uuid(),
  pinned: z.boolean(),
});

/**
 * Admin notes router with all note-related procedures
 */
export const adminNotesRouter = router({
  /**
   * Create a new customer note
   */
  createNote: adminProcedure
    .input(CreateNoteSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        // Verify customer exists
        const customerExists = await ctx.prisma.customer.findUnique({
          where: { id: input.customerId },
          select: { id: true }
        });

        if (!customerExists) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Customer with ID ${input.customerId} not found`
          });
        }

        // Create the note
        const note = await ctx.prisma.note.create({
          data: {
            content: input.content,
            type: input.type.toUpperCase() as NoteType,
            pinned: input.pinned ?? false,
            customer: {
              connect: { id: input.customerId }
            },
            createdBy: ctx.userId as string
          }
        });

        return note;
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to create note: ${error.message}`,
            cause: error
          });
        }

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'An unexpected error occurred while creating the note'
        });
      }
    }),

  /**
   * Update an existing note
   */
  updateNote: adminProcedure
    .input(UpdateNoteSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        // Check if note exists and belongs to the correct customer
        const existingNote = await ctx.prisma.note.findUnique({
          where: { id: input.id },
          select: { id: true, customerId: true }
        });

        if (!existingNote) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Note with ID ${input.id} not found`
          });
        }

        // Build update data object, excluding undefined values
        const updateData: Prisma.NoteUpdateInput = {
          updatedAt: new Date()
        };

        if (input.content !== undefined) {
          updateData['content'] = input.content;
        }

        if (input.type !== undefined) {
          updateData['type'] = input.type.toUpperCase() as NoteType;
        }

        if (input.pinned !== undefined) {
          updateData['pinned'] = input.pinned;
        }

        // Update the note
        const updatedNote = await ctx.prisma.note.update({
          where: { id: input.id },
          data: updateData
        });

        return updatedNote;
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to update note: ${error.message}`,
            cause: error
          });
        }

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'An unexpected error occurred while updating the note'
        });
      }
    }),

  /**
   * Delete a note
   */
  deleteNote: adminProcedure
    .input(DeleteNoteSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        // Check if note exists
        const existingNote = await ctx.prisma.note.findUnique({
          where: { id: input.id },
          select: { id: true }
        });

        if (!existingNote) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Note with ID ${input.id} not found`
          });
        }

        // Delete the note
        await ctx.prisma.note.delete({
          where: { id: input.id }
        });

        return { success: true };
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to delete note: ${error.message}`,
            cause: error
          });
        }

        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'An unexpected error occurred while deleting the note'
        });
      }
    }),

  /**
   * Get notes for a specific customer
   */
  getNotesByCustomer: adminProcedure
    .input(GetNotesByCustomerSchema)
    .query(async ({ input, ctx }) => {
      try {
        // Verify customer exists
        const customerExists = await ctx.prisma.customer.findUnique({
          where: { id: input.customerId },
          select: { id: true }
        });

        if (!customerExists) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Customer with ID ${input.customerId} not found`
          });
        }

        // Build where clause
        const where: Prisma.NoteWhereInput = { 
          customerId: input.customerId 
        };

        // Add type filter if specified
        if (input.type) {
          where.type = input.type;
        }

        // Add pinned filter if specified
        if (input.pinnedOnly) {
          where.pinned = true;
        }

        // Calculate skip from cursor
        const skip = input.cursor ? parseInt(input.cursor) : 0;

        // Get notes with pagination
        const notes = await ctx.prisma.note.findMany({
          where,
          orderBy: [
            { pinned: 'desc' },
            { updatedAt: 'desc' }
          ],
          skip,
          take: input.limit,
        });

        // Get total count
        const totalCount = await ctx.prisma.note.count({
          where
        });

        return {
          notes,
          totalCount,
          hasMore: skip + input.limit < totalCount
        };
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to retrieve customer notes'
        });
      }
    }),

  /**
   * Pin or unpin a note
   */
  pinNote: adminProcedure
    .input(PinNoteSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        // Check if note exists
        const existingNote = await ctx.prisma.note.findUnique({
          where: { id: input.id },
          select: { id: true }
        });

        if (!existingNote) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Note with ID ${input.id} not found`
          });
        }

        // Update the pin status
        const updatedNote = await ctx.prisma.note.update({
          where: { id: input.id },
          data: {
            pinned: input.pinned,
            updatedAt: new Date()
          }
        });

        return updatedNote;
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to update note pin status'
        });
      }
    })
});/**
 * Admin Main Router
 *
 * This router aggregates all admin sub-routers into a single admin router.
 * It follows the same pattern as the dashboard router, providing a modular
 * and maintainable approach to organizing admin functionality.
 */
import { router } from '../../procedures';
import { adminNotesRouter } from './notes-router';
import { adminUsersRouter } from './users-router';
import { adminMetricsRouter } from './metrics-router';

/**
 * Combined admin router that aggregates all admin-specific sub-routers
 */
export const adminMainRouter = router({
  // Notes management
  notes: adminNotesRouter,
  
  // User management
  users: adminUsersRouter,
  
  // Metrics and statistics
  metrics: adminMetricsRouter,
});/**
 * Admin Users Router
 *
 * This router handles all user management operations for admin users,
 * including listing, creating, updating, and deleting users.
 */
import { z } from 'zod';
import { adminProcedure, router } from '../../procedures';
import { TRPCError } from '@trpc/server';
import { Prisma } from '@prisma/client';
import { logger } from '@/lib/logger';

/**
 * Admin users router with all user management procedures
 */
export const adminUsersRouter = router({
  /**
   * Get all users with pagination and filtering
   */
  getUsers: adminProcedure
    .input(z.object({
      skip: z.number().int().min(0).default(0),
      take: z.number().int().min(1).max(100).default(50),
      search: z.string().optional(),
      role: z.string().optional(),
      sortBy: z.enum(['name', 'email', 'createdAt', 'role']).default('createdAt'),
      sortOrder: z.enum(['asc', 'desc']).default('desc'),
    }))
    .query(async ({ input, ctx }) => {
      try {
        const { skip, take, search, role, sortBy, sortOrder } = input;

        // Build where clause
        const where: Prisma.UserWhereInput = {};
        
        // Add search filter if provided
        if (search) {
          where.OR = [
            { name: { contains: search, mode: 'insensitive' } },
            { email: { contains: search, mode: 'insensitive' } },
          ];
        }
        
        // Add role filter if provided
        if (role) {
          where.role = role;
        }

        // Build order by clause
        const orderBy: Prisma.UserOrderByWithRelationInput = {
          [sortBy]: sortOrder,
        };

        // Get users with pagination
        const [users, totalCount] = await Promise.all([
          ctx.prisma.user.findMany({
            skip,
            take,
            where,
            orderBy,
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
              role: true,
              emailVerified: true,
              createdAt: true,
              updatedAt: true,
              // Omit sensitive fields like password hash
            },
          }),
          ctx.prisma.user.count({ where }),
        ]);

        return {
          users,
          totalCount,
          pagination: {
            skip,
            take,
            hasMore: skip + take < totalCount,
          },
        };
      } catch (error) {
        logger.error('Error fetching users', { error });
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch users',
        });
      }
    }),

  /**
   * Get a single user by ID
   */
  getUserById: adminProcedure
    .input(z.object({
      id: z.string(),
    }))
    .query(async ({ input, ctx }) => {
      try {
        const user = await ctx.prisma.user.findUnique({
          where: { id: input.id },
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            role: true,
            emailVerified: true,
            createdAt: true,
            updatedAt: true,
            // Omit sensitive fields
          },
        });

        if (!user) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `User with ID ${input.id} not found`,
          });
        }

        return user;
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        logger.error('Error fetching user by ID', { error, userId: input.id });
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch user',
        });
      }
    }),

  /**
   * Update user role
   */
  updateUserRole: adminProcedure
    .input(z.object({
      userId: z.string(),
      role: z.string(),
    }))
    .mutation(async ({ input, ctx }) => {
      try {
        const { userId, role } = input;

        // Check if user exists
        const existingUser = await ctx.prisma.user.findUnique({
          where: { id: userId },
          select: { id: true },
        });

        if (!existingUser) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `User with ID ${userId} not found`,
          });
        }

        // Update user role
        await ctx.prisma.user.update({
          where: { id: userId },
          data: { role },
        });

        // Log the role change
        logger.info('User role updated', {
          updatedUserId: userId,
          role,
          adminId: ctx.userId,
        });

        return { success: true };
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        logger.error('Error updating user role', { 
          error, 
          userId: input.userId, 
          role: input.role 
        });
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to update user role',
        });
      }
    }),

  /**
   * Deactivate a user account (soft delete)
   */
  deactivateUser: adminProcedure
    .input(z.object({
      userId: z.string(),
    }))
    .mutation(async ({ input, ctx }) => {
      try {
        const { userId } = input;

        // Prevent deactivating your own account
        if (userId === ctx.userId) {
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: 'You cannot deactivate your own account',
          });
        }

        // Check if user exists
        const existingUser = await ctx.prisma.user.findUnique({
          where: { id: userId },
          select: { id: true },
        });

        if (!existingUser) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `User with ID ${userId} not found`,
          });
        }

        // Soft delete by setting active flag to false
        // Note: This assumes you have an 'active' field in your User model
        await ctx.prisma.user.update({
          where: { id: userId },
          data: { 
            active: false,
            updatedAt: new Date()
          },
        });

        // Log the deactivation
        logger.info('User deactivated', {
          deactivatedUserId: userId,
          adminId: ctx.userId,
        });

        return { success: true };
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        logger.error('Error deactivating user', { 
          error, 
          userId: input.userId
        });
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to deactivate user',
        });
      }
    }),

  /**
   * Reactivate a previously deactivated user account
   */
  reactivateUser: adminProcedure
    .input(z.object({
      userId: z.string(),
    }))
    .mutation(async ({ input, ctx }) => {
      try {
        const { userId } = input;

        // Check if user exists
        const existingUser = await ctx.prisma.user.findUnique({
          where: { id: userId },
          select: { id: true, active: true },
        });

        if (!existingUser) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `User with ID ${userId} not found`,
          });
        }

        // If already active, return success
        if (existingUser.active) {
          return { success: true, message: 'User is already active' };
        }

        // Reactivate user
        await ctx.prisma.user.update({
          where: { id: userId },
          data: { 
            active: true,
            updatedAt: new Date()
          },
        });

        // Log the reactivation
        logger.info('User reactivated', {
          reactivatedUserId: userId,
          adminId: ctx.userId,
        });

        return { success: true };
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        logger.error('Error reactivating user', { 
          error, 
          userId: input.userId
        });
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to reactivate user',
        });
      }
    }),

  /**
   * Get user activity log
   */
  getUserActivityLog: adminProcedure
    .input(z.object({
      userId: z.string(),
      limit: z.number().int().min(1).max(100).default(50),
      offset: z.number().int().min(0).default(0),
    }))
    .query(async ({ input, ctx }) => {
      try {
        const { userId, limit, offset } = input;

        // Check if user exists
        const existingUser = await ctx.prisma.user.findUnique({
          where: { id: userId },
          select: { id: true },
        });

        if (!existingUser) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `User with ID ${userId} not found`,
          });
        }

        // Get user activity logs - this would depend on your schema
        // This is a placeholder implementation
        const activityLogs = await ctx.prisma.userActivity.findMany({
          where: { userId },
          orderBy: { timestamp: 'desc' },
          skip: offset,
          take: limit,
        }).catch(() => {
          // If the table doesn't exist yet, return empty array
          return [];
        });

        // Count total logs
        const totalLogs = await ctx.prisma.userActivity.count({
          where: { userId },
        }).catch(() => 0);

        return {
          logs: activityLogs,
          pagination: {
            total: totalLogs,
            offset,
            limit,
            hasMore: offset + limit < totalLogs,
          },
        };
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        logger.error('Error fetching user activity log', { 
          error, 
          userId: input.userId
        });
        
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch user activity log',
        });
      }
    }),
});/**
 * Admin Metrics Router
 *
 * This router handles all metrics and stats-related admin operations
 * for the dashboard and analytics features.
 */
import { z } from 'zod';
import { adminProcedure, router } from '../../procedures';
import { TRPCError } from '@trpc/server';
import { logger } from '@/lib/logger';

/**
 * Admin metrics router with all metrics and stats procedures
 */
export const adminMetricsRouter = router({
  /**
   * Get comprehensive dashboard statistics
   */
  getDashboardStats: adminProcedure.query(async ({ ctx }) => {
    try {
      // Get counts from different entities with proper error handling
      const [
        usersCount,
        customersCount,
        designsCount,
        testimonialsCount
      ] = await Promise.all([
        ctx.prisma.user.count().catch(error => {
          logger.error('Error counting users', { error });
          return 0;
        }),
        ctx.prisma.customer.count().catch(error => {
          logger.error('Error counting customers', { error });
          return 0;
        }),
        // Designs count - set to 0 for now as there's no design model
        Promise.resolve(0),
        // Testimonials count - set to 0 for now as there's no testimonial field
        Promise.resolve(0)
      ]);

      // Get booking and appointment counts from Cal.com integration
      // These were stubs in the original implementation
      // Now we're implementing proper queries
      const bookingsCount = await ctx.prisma.calBooking.count().catch(error => {
        logger.error('Error counting Cal.com bookings', { error });
        return 0;
      });

      const appointmentsCount = await ctx.prisma.appointment.count().catch(error => {
        logger.error('Error counting appointments', { error });
        return 0;
      });

      // Get artist count - using users with artist role
      const artistsCount = await ctx.prisma.user.count({
        where: {
          role: 'artist'
        }
      }).catch(error => {
        logger.error('Error counting artists', { error });
        return 0;
      });

      // Get recent bookings with customer info
      const recentBookings = await ctx.prisma.calBooking.findMany({
        take: 5,
        orderBy: { createdAt: 'desc' },
        include: {
          customer: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              phone: true
            }
          }
        }
      }).catch(error => {
        logger.error('Error fetching recent bookings', { error });
        return [];
      });

      // Get event types for recent bookings to map service names
      const recentBookingEventTypeIds = [...new Set(recentBookings.map(b => b.eventTypeId))];
      const recentEventTypes = await ctx.prisma.calEventType.findMany({
        where: {
          calEventTypeId: {
            in: recentBookingEventTypeIds,
          },
        },
        select: {
          calEventTypeId: true,
          title: true,
        },
      }).catch(error => {
        logger.error('Error fetching event types for recent bookings', { error });
        return [];
      });

      // Create event type lookup map
      const eventTypeNameMap = new Map(
        recentEventTypes.map(et => [et.calEventTypeId, et.title])
      );

      // Enhance bookings with proper service names and customer names
      const enhancedRecentBookings = recentBookings.map(booking => ({
        ...booking,
        serviceName: eventTypeNameMap.get(booking.eventTypeId) ?? booking.serviceName,
        customer: booking.customer ? {
          ...booking.customer,
          name: `${booking.customer.firstName} ${booking.customer.lastName}`.trim() || booking.customer.email
        } : null
      }));

      // Get upcoming appointments with customer info
      const upcomingAppointments = await ctx.prisma.appointment.findMany({
        where: {
          startTime: {
            gte: new Date()
          }
        },
        take: 5,
        orderBy: { startTime: 'asc' },
        include: {
          customer: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              phone: true
            }
          }
        }
      }).catch(error => {
        logger.error('Error fetching upcoming appointments', { error });
        return [];
      });

      // Enhance appointments with customer names
      const enhancedAppointments = upcomingAppointments.map(appointment => ({
        ...appointment,
        customer: appointment.customer ? {
          ...appointment.customer,
          name: `${appointment.customer.firstName} ${appointment.customer.lastName}`.trim() || appointment.customer.email
        } : null
      }));

      // Return all stats
      return {
        counts: {
          users: usersCount,
          customers: customersCount,
          bookings: bookingsCount,
          appointments: appointmentsCount,
          artists: artistsCount,
          testimonials: testimonialsCount,
          designs: designsCount,
        },
        recentActivity: {
          bookings: enhancedRecentBookings,
          appointments: enhancedAppointments,
        }
      };
    } catch (error) {
      logger.error('Error getting dashboard stats', { error });
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Failed to fetch dashboard statistics'
      });
    }
  }),

  /**
   * Get booking statistics with time range filtering
   */
  getBookingStats: adminProcedure
    .input(
      z.object({
        startDate: z.string().optional(),
        endDate: z.string().optional(),
        interval: z.enum(['day', 'week', 'month']).default('day')
      })
    )
    .query(async ({ input, ctx }) => {
      try {
        const { startDate, endDate, interval } = input;
        
        // Parse dates or use defaults
        const start = startDate ? new Date(startDate) : new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        const end = endDate ? new Date(endDate) : new Date();
        
        // Build date filter
        const dateFilter = {
          createdAt: {
            gte: start,
            lte: end,
          },
        };

        // Get booking counts
        const totalBookings = await ctx.prisma.calBooking.count({
          where: dateFilter,
        });

        // Get completed bookings (those with COMPLETED status)
        const completedBookings = await ctx.prisma.calBooking.count({
          where: {
            ...dateFilter,
            status: 'COMPLETED',
          },
        });

        // Get conversion rate
        const conversionRate = totalBookings > 0 
          ? (completedBookings / totalBookings) * 100
          : 0;

        // Get bookings by service type with names
        const bookingsByService = await ctx.prisma.calBooking.groupBy({
          by: ['eventTypeId'],
          _count: {
            id: true,
          },
          where: dateFilter,
        });

        // Get event type details for service name mapping
        const eventTypeIds = bookingsByService.map(booking => booking.eventTypeId);
        const eventTypes = await ctx.prisma.calEventType.findMany({
          where: {
            calEventTypeId: {
              in: eventTypeIds,
            },
          },
          select: {
            calEventTypeId: true,
            title: true,
            slug: true,
            price: true,
            currency: true,
          },
        });

        // Create a lookup map for efficient service name mapping
        const eventTypeLookup = new Map(
          eventTypes.map(et => [et.calEventTypeId, {
            name: et.title,
            slug: et.slug,
            price: et.price,
            currency: et.currency,
          }])
        );

        // Map bookings with service names
        const bookingsByServiceWithNames = bookingsByService.map(booking => ({
          eventTypeId: booking.eventTypeId,
          serviceName: eventTypeLookup.get(booking.eventTypeId)?.name ?? `Service #${booking.eventTypeId}`,
          serviceSlug: eventTypeLookup.get(booking.eventTypeId)?.slug ?? '',
          servicePrice: eventTypeLookup.get(booking.eventTypeId)?.price ?? 0,
          serviceCurrency: eventTypeLookup.get(booking.eventTypeId)?.currency ?? 'USD',
          count: booking._count.id,
        }));

        return {
          totalBookings,
          completedBookings,
          conversionRate: parseFloat(conversionRate.toFixed(2)),
          bookingsByService: bookingsByServiceWithNames,
          timeRange: {
            start: start.toISOString(),
            end: end.toISOString(),
            interval,
          },
        };
      } catch (error) {
        logger.error('Error getting booking stats', { error });
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch booking statistics',
        });
      }
    }),
  
  /**
   * Get customer growth statistics
   */
  getCustomerGrowthStats: adminProcedure
    .input(
      z.object({
        months: z.number().int().min(1).max(24).default(12),
      })
    )
    .query(async ({ input, ctx }) => {
      try {
        const { months } = input;
        
        // Calculate start date based on number of months
        const startDate = new Date();
        startDate.setMonth(startDate.getMonth() - months);
        
        // Get all customers created within the time range
        const customers = await ctx.prisma.customer.findMany({
          where: {
            createdAt: {
              gte: startDate,
            },
          },
          select: {
            id: true,
            createdAt: true,
          },
          orderBy: {
            createdAt: 'asc',
          },
        });
        
        // Group by month for the chart
        const monthlyGrowth: Record<string, number> = {};
        
        // Initialize all months with 0
        for (let i = 0; i < months; i++) {
          const date = new Date();
          date.setMonth(date.getMonth() - i);
          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          monthlyGrowth[monthKey] = 0;
        }
        
        // Count customers by month
        customers.forEach(customer => {
          const date = new Date(customer.createdAt);
          const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
          monthlyGrowth[monthKey] = (monthlyGrowth[monthKey] ?? 0) + 1;
        });
        
        // Calculate total and growth rate
        const totalNewCustomers = customers.length;
        
        // Format for chart display (convert object to array)
        const growthData = Object.entries(monthlyGrowth).map(([month, count]) => ({
          month,
          count,
        })).sort((a, b) => a.month.localeCompare(b.month));
        
        return {
          totalNewCustomers,
          growthByMonth: growthData,
          timeRange: {
            startDate: startDate.toISOString(),
            endDate: new Date().toISOString(),
          },
        };
      } catch (error) {
        logger.error('Error getting customer growth stats', { error });
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch customer growth statistics',
        });
      }
    }),
});/**
 * Subscription Router
 *
 * This router handles all real-time subscription endpoints using tRPC's
 * subscription feature with Server-Sent Events (SSE).
 * 
 * This implementation includes:
 * - Memory-safe EventManager with memory leak prevention
 * - Strong type safety and validation
 * - Proper error handling with structured logging
 * - Rate limiting for subscription endpoints
 * - Resource cleanup on unsubscribe
 */
import { z } from 'zod';
import { publicProcedure, protectedProcedure, adminProcedure, router } from '../procedures';
import { observable } from '@trpc/server/observable';
import { TRPCError } from '@trpc/server';
import { logger } from '@/lib/logger';
import { UserRole } from '@prisma/client';
import { prisma } from '@/lib/db/prisma';

// =============================================================================
// Event Manager - Memory-Safe Implementation
// =============================================================================

/**
 * Type-safe EventManager to handle real-time events with memory management
 * Uses a Map-based storage to prevent memory leaks and track subscribers
 */
class EventManager<T extends Record<string, unknown>> {
  private events = new Map<string, Map<string, (data: unknown) => void>>();
  private subscriptionCounts = new Map<string, number>();
  private readonly maxListenersPerEvent: number;
  private readonly debugMode: boolean;
  
  constructor(options?: { maxListenersPerEvent?: number; debug?: boolean }) {
    this.maxListenersPerEvent = options?.maxListenersPerEvent ?? 100;
    this.debugMode = options?.debug ?? false;
  }

  /**
   * Subscribe to an event with a unique subscriber ID
   * @param eventName The event to subscribe to
   * @param subscriberId Unique ID for this subscriber
   * @param callback Function to call when event occurs
   * @returns Unsubscribe function
   */
  on<E extends keyof T & string>(
    eventName: E, 
    subscriberId: string, 
    callback: (data: T[E]) => void
  ): () => void {
    // Check if we've reached the max listeners limit
    const count = this.subscriptionCounts.get(eventName) ?? 0;
    if (count >= this.maxListenersPerEvent) {
      logger.warn('Max listeners reached for event', { eventName, count });
      throw new Error(`Max listeners (${this.maxListenersPerEvent}) reached for event: ${eventName}`);
    }
    
    // Get or create the event subscribers map
    if (!this.events.has(eventName)) {
      this.events.set(eventName, new Map());
      this.subscriptionCounts.set(eventName, 0);
    }
    
    const subscribers = this.events.get(eventName) ?? new Map();
    
    // Add the subscriber with proper type casting
    subscribers.set(subscriberId, callback as (data: unknown) => void);
    this.subscriptionCounts.set(eventName, count + 1);
    
    if (this.debugMode) {
      logger.debug('Subscription added', { 
        eventName, 
        subscriberId, 
        totalSubscribers: subscribers.size 
      });
    }
    
    // Return unsubscribe function
    return () => {
      this.off(eventName, subscriberId);
    };
  }

  /**
   * Unsubscribe from an event
   * @param eventName The event to unsubscribe from
   * @param subscriberId Unique ID for this subscriber
   */
  off<E extends keyof T & string>(eventName: E, subscriberId: string): void {
    const subscribers = this.events.get(eventName);
    if (!subscribers) return;
    
    const deleted = subscribers.delete(subscriberId);
    
    if (deleted) {
      const count = this.subscriptionCounts.get(eventName) ?? 0;
      this.subscriptionCounts.set(eventName, Math.max(0, count - 1));
      
      if (this.debugMode) {
        logger.debug('Subscription removed', { 
          eventName, 
          subscriberId, 
          totalSubscribers: subscribers.size 
        });
      }
      
      // Clean up empty event maps to prevent memory leaks
      if (subscribers.size === 0) {
        this.events.delete(eventName);
        this.subscriptionCounts.delete(eventName);
      }
    }
  }

  /**
   * Emit an event to all subscribers
   * @param eventName The event to emit
   * @param data The data to send with the event
   */
  emit<E extends keyof T & string>(eventName: E, data: T[E]): void {
    const subscribers = this.events.get(eventName);
    if (!subscribers || subscribers.size === 0) return;
    
    // Track errors but continue attempting to deliver to all subscribers
    const errors: Error[] = [];
    
    // Call all subscriber callbacks
    for (const [subscriberId, callback] of subscribers.entries()) {
      try {
        callback(data);
      } catch (error) {
        // Catch any errors in subscriber callbacks to prevent one bad subscriber
        // from affecting others
        const err = error instanceof Error ? error : new Error(String(error));
        errors.push(err);
        logger.error('Error in event subscriber callback', { 
          eventName, 
          subscriberId, 
          error: err.message,
          stack: err.stack 
        });
        
        // Remove problematic subscriber to prevent recurring errors
        subscribers.delete(subscriberId);
        const count = this.subscriptionCounts.get(eventName) ?? 0;
        this.subscriptionCounts.set(eventName, Math.max(0, count - 1));
      }
    }
    
    if (errors.length > 0) {
      logger.warn('Errors occurred while emitting event', { 
        eventName, 
        errorCount: errors.length,
        subscriberCount: subscribers.size 
      });
    }
  }

  /**
   * Get current subscription counts
   * @returns Object with event names and subscription counts
   */
  getStats(): Record<string, number> {
    const stats: Record<string, number> = {};
    for (const [eventName, count] of this.subscriptionCounts.entries()) {
      stats[eventName] = count;
    }
    return stats;
  }

  /**
   * Remove all subscriptions for cleanup
   */
  removeAllListeners(): void {
    this.events.clear();
    this.subscriptionCounts.clear();
    logger.info('All event listeners removed');
  }
}

// Create strongly-typed event interface
interface EventTypes {
  booking: BookingEvent;
  appointment: AppointmentEvent;
  customer: CustomerEvent;
  gallery: GalleryEvent;
  [key: string]: unknown;
}

// Create the event manager instance with debugging in development
const eventManager = new EventManager<EventTypes>({ 
  maxListenersPerEvent: 100,
  debug: process.env.NODE_ENV === 'development'
});

// =============================================================================
// Event Data Types
// =============================================================================

// Base event data interfaces
interface BookingEventData {
  id: number;
  name?: string;
  email?: string;
  artistId?: string;
  customerId?: string;
  preferredDate?: Date;
  tattooType?: string;
  status?: string;
  depositPaid?: boolean;
  createdAt?: Date;
  updatedAt?: Date;
  deletedAt?: Date;
  [key: string]: unknown;
}

interface AppointmentEventData {
  id: string;
  title?: string;
  startDate?: Date;
  endDate?: Date;
  status?: string;
  artistId?: string;
  customerId?: string;
  bookingId?: number;
  location?: string;
  notes?: string;
  createdAt?: Date;
  updatedAt?: Date;
  deletedAt?: Date;
  [key: string]: unknown;
}

interface CustomerEventData {
  id: string;
  firstName?: string;
  lastName?: string;
  email?: string;
  phone?: string;
  createdAt?: Date;
  updatedAt?: Date;
  noteId?: string;
  content?: string;
  type?: string;
  tagId?: string;
  tagName?: string;
  tagColor?: string;
  [key: string]: unknown;
}

interface GalleryEventData {
  id: string;
  title?: string;
  url?: string;
  thumbUrl?: string;
  artistId?: string;
  isApproved?: boolean;
  createdAt?: Date;
  updatedAt?: Date;
  deletedAt?: Date;
  category?: string | null;
  tags?: string[] | null;
  dimensions?: string | null;
  [key: string]: unknown;
}

// Define dashboard activity event type
interface DashboardActivityEvent {
  type: string;
  data: BookingEvent | AppointmentEvent | CustomerEvent | GalleryEvent;
  timestamp: Date;
}

// Define specific event types
type BookingEvent = {
  id: number;
  type: 'created' | 'updated' | 'deleted';
  data: BookingEventData;
};

type AppointmentEvent = {
  id: string;
  type: 'created' | 'updated' | 'deleted' | 'status_changed';
  data: AppointmentEventData;
};

type CustomerEvent = {
  id: string;
  type: 'created' | 'updated' | 'note_added' | 'tag_added' | 'tag_removed';
  data: CustomerEventData;
};

type GalleryEvent = {
  id: string;
  type: 'created' | 'updated' | 'deleted' | 'approved';
  data: GalleryEventData;
};

// =============================================================================
// Event Emitter Functions
// =============================================================================

/**
 * Emit a booking event
 * @param event Booking event to emit
 */
export function emitBookingEvent(event: BookingEvent): void {
  // Validate event data to ensure it meets requirements
  if (!event?.id || !event.type || !event.data) {
    logger.warn('Invalid booking event data. Event not emitted.', { event });
    return;
  }
  
  try {
    eventManager.emit('booking', event);
    logger.debug('Booking event emitted', { id: event.id, type: event.type });
  } catch (error) {
    logger.error('Failed to emit booking event', { 
      error: error instanceof Error ? error.message : 'Unknown error',
      id: event.id, 
      type: event.type 
    });
  }
}

/**
 * Emit an appointment event
 * @param event Appointment event to emit
 */
export function emitAppointmentEvent(event: AppointmentEvent): void {
  // Validate event data to ensure it meets requirements
  if (!event?.id || !event.type || !event.data) {
    logger.warn('Invalid appointment event data. Event not emitted.', { event });
    return;
  }

  try {
    eventManager.emit('appointment', event);
    logger.debug('Appointment event emitted', { id: event.id, type: event.type });
  } catch (error) {
    logger.error('Failed to emit appointment event', { 
      error: error instanceof Error ? error.message : 'Unknown error',
      id: event.id, 
      type: event.type 
    });
  }
}

/**
 * Emit a customer event
 * @param event Customer event to emit
 */
export function emitCustomerEvent(event: CustomerEvent): void {
  // Validate event data to ensure it meets requirements
  if (!event?.id || !event.type || !event.data) {
    logger.warn('Invalid customer event data. Event not emitted.', { event });
    return;
  }

  try {
    eventManager.emit('customer', event);
    logger.debug('Customer event emitted', { id: event.id, type: event.type });
  } catch (error) {
    logger.error('Failed to emit customer event', { 
      error: error instanceof Error ? error.message : 'Unknown error',
      id: event.id, 
      type: event.type 
    });
  }
}

/**
 * Emit a gallery event
 * @param event Gallery event to emit
 */
export function emitGalleryEvent(event: GalleryEvent): void {
  // Validate event data to ensure it meets requirements
  if (!event?.id || !event.type || !event.data) {
    logger.warn('Invalid gallery event data. Event not emitted.', { event });
    return;
  }

  try {
    eventManager.emit('gallery', event);
    logger.debug('Gallery event emitted', { id: event.id, type: event.type });
  } catch (error) {
    logger.error('Failed to emit gallery event', { 
      error: error instanceof Error ? error.message : 'Unknown error',
      id: event.id, 
      type: event.type 
    });
  }
}

// =============================================================================
// Validation Schemas
// =============================================================================

const BookingFilterSchema = z.object({
  artistId: z.string().optional(),
}).optional();

const AppointmentFilterSchema = z.object({
  artistId: z.string().optional(),
  customerId: z.string().optional(),
}).optional();

const CustomerFilterSchema = z.object({
  customerId: z.string().optional(),
}).optional();

const GalleryFilterSchema = z.object({
  limit: z.number().min(1).max(50).default(10),
  categories: z.array(z.string()).optional(),
}).optional();

// =============================================================================
// Helper Functions
// =============================================================================

/**
 * Check if a user has the required permissions
 * @param userId User ID
 * @param requiredPermissions Array of permissions to check
 * @returns True if user has all required permissions
 */
async function validateUserPermissions(
  userId: string, 
  requiredPermissions: string[]
): Promise<boolean> {
  try {
    // Get user's role from database
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { role: true }
    });
    
    if (!user) {
      logger.warn('User not found when validating permissions', { userId });
      return false;
    }
    
    // Check permissions based on role
    const userRole = user.role as UserRole;
    
    // Admins have all permissions
    if (userRole === UserRole.ADMIN) {
      return true;
    }
    
    // Artists have specific permissions
    if (userRole === UserRole.ARTIST) {
      // Implement role-based permissions logic here
      // For now, simplify by returning true for basic artist permissions
      const artistPermissions = [
        'VIEW_BOOKINGS',
        'UPDATE_GALLERY',
        'VIEW_OWN_BOOKINGS'
      ];
      
      return requiredPermissions.every(perm => artistPermissions.includes(perm));
    }
    
    return false;
  } catch (error) {
    logger.error('Error validating user permissions', { 
      userId,
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    return false;
  }
}

/**
 * Safely sanitize event data to remove sensitive information
 * @param event The event to sanitize
 * @param sensitiveFields Fields to remove
 * @returns Sanitized event
 */
function sanitizeEventData<T extends Record<string, unknown> & { data?: Record<string, unknown> }>(
  event: T, 
  sensitiveFields: string[]
): T {
  // Create a shallow copy of the event
  const sanitized = { ...event };
  
  // If the event has a data property, sanitize it
  if (sanitized && 'data' in sanitized && sanitized.data && typeof sanitized.data === 'object') {
    // Cast to a record type to ensure TypeScript understands we're using an index signature
    const dataRecord = sanitized.data as Record<string, unknown>;
    sanitized.data = { ...dataRecord };
    
    // Remove sensitive fields from the data
    for (const field of sensitiveFields) {
      // Use proper object access to avoid index signature access errors
      if (Object.prototype.hasOwnProperty.call(dataRecord, field)) {
        delete (sanitized.data as Record<string, unknown>)[field];
      }
    }
  }
  
  return sanitized;
}

// Removed unused getArtistId function

// =============================================================================
// Subscription Router Implementation
// =============================================================================

export const subscriptionRouter = router({
  // ===========================================================================
  // BOOKING EVENTS SUBSCRIPTION
  // ===========================================================================
  bookingEvents: protectedProcedure
    .input(BookingFilterSchema)
    .subscription(async ({ input, ctx }) => {
      // Verify user has access to booking events based on their role
      let isAdmin = false;
      let isArtist = false;
      let artistId: string | null = null;
      
      try {
        // Validate user session and permissions
        if (!ctx.userId) {
          throw new TRPCError({
            code: 'UNAUTHORIZED',
            message: 'Authentication required to access booking events'
          });
        }
        
        // Get user's role and profile from database
        const user = await prisma.user.findUnique({
          where: { id: ctx.userId },
          select: { 
            id: true,
            role: true
            // Remove artist relation since it doesn't exist in the schema
          }
        });
        
        if (!user) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'User profile not found'
          });
        }
        
        isAdmin = user.role === UserRole.ADMIN;
        isArtist = user.role === UserRole.ARTIST;
        
        // Get artist ID if user is an artist - using user ID as artist ID
        if (isArtist) {
          artistId = user.id; // Use user ID as artist ID since there's no artist relation
        }
        
        // Role-based access control for booking events
        if (isArtist && input?.artistId) {
          // Artists can only access their own bookings
          if (artistId !== input.artistId) {
            throw new TRPCError({
              code: 'FORBIDDEN',
              message: 'Artists can only subscribe to their own booking events'
            });
          }
        }
        
        // Verify permission to access booking events
        if (!isAdmin && !isArtist) {
          throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'Insufficient permissions to access booking events'
          });
        }

        // Log subscription start
        logger.info('User subscribed to booking events', {
          userId: ctx.userId,
          isAdmin,
          isArtist,
          artistId: input?.artistId
        });
      } catch (error) {
        logger.error('Error in booking events subscription', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          userId: ctx.userId 
        });
        throw error instanceof TRPCError ? error : new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to initialize booking events subscription',
          cause: error
        });
      }

      // Create unique subscriber ID to prevent memory leaks
      const subscriberId = `booking-${ctx.userId}-${Date.now()}`;
      
      // Set up rate limiting
      const maxEventsPerMinute = 60;
      let eventCount = 0;
      let lastRateLimitReset = Date.now();
      
      // List of sensitive fields to remove based on role
      const sensitiveFields = isAdmin ? [] : [
        'internalNotes',
        'paymentDetails',
        'adminComments',
        'financialData',
        'sensitiveCustomerInfo'
      ];

      // Create observable for subscription
      return observable<BookingEvent>((emit) => {
        const onBookingEvent = (data: BookingEvent) => {
          try {
            // Apply rate limiting
            const now = Date.now();
            if (now - lastRateLimitReset > 60000) {
              eventCount = 0;
              lastRateLimitReset = now;
            }
            
            if (eventCount >= maxEventsPerMinute) {
              logger.warn('Rate limit exceeded for booking events', { userId: ctx.userId });
              return;
            }
            
            eventCount++;
            
            // First, validate the event data to ensure it meets security requirements
            if (!data?.id) {
              logger.warn('Received invalid booking event data', { eventData: data });
              return;
            }
            
            // Filter by artistId if provided in the subscription request
            if (input?.artistId && data.data.artistId !== input.artistId) {
              return; // Skip events not matching the requested artist
            }

            // Apply role-based access control
            if (isAdmin) {
              // Admins can see all booking events
              emit.next(data);
            } else if (isArtist && artistId) {
              if (data.data.artistId === artistId) {
                // Remove any sensitive information before sending to artists
                const sanitizedData = sanitizeEventData(data, sensitiveFields);
                emit.next(sanitizedData);
              }
            }
          } catch (error) {
            logger.error('Error processing booking event', { 
              error: error instanceof Error ? error.message : 'Unknown error',
              eventId: data.id 
            });
          }
        };

        // Subscribe to booking events
        const unsubscribe = eventManager.on('booking', subscriberId, onBookingEvent);

        // Cleanup when client unsubscribes
        return () => {
          unsubscribe();
          logger.debug('User unsubscribed from booking events', { userId: ctx.userId });
        };
      });
    }),

  // ===========================================================================
  // APPOINTMENT EVENTS SUBSCRIPTION
  // ===========================================================================
  appointmentEvents: protectedProcedure
    .input(AppointmentFilterSchema)
    .subscription(async ({ input, ctx }) => {
      // Verify user has access to appointment events
      let isAdmin = false;
      let isArtist = false;
      let isCustomer = false;
      let customerIds: string[] = [];
      let artistId: string | null = null;
      
      try {
        // Get user's role and relevant IDs from database
        if (!ctx.userId) {
          throw new TRPCError({
            code: 'UNAUTHORIZED',
            message: 'Authentication required to access appointment events'
          });
        }
        
        const user = await prisma.user.findUnique({
          where: { id: ctx.userId },
          select: { 
            role: true
            // No artist or customer relation in schema
          }
        });

        if (!user) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'User profile not found'
          });
        }

        isAdmin = user.role === UserRole.ADMIN;
        isArtist = user.role === UserRole.ARTIST;
        isCustomer = user.role === UserRole.CUSTOMER;
        
        // Get artist ID if user is an artist - use userId
        if (isArtist) {
          artistId = ctx.userId; // Use userId as artistId
        }
        
        // Get customer ID if user is a client - use userId
        if (isCustomer) {
          customerIds = [ctx.userId]; // Use userId as customerId
        }
        
        // Role-based access control checks
        if (isArtist && input?.artistId && artistId !== input.artistId) {
          throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'Artists can only subscribe to their own appointment events'
          });
        }
        
        if (isCustomer && input?.customerId && !customerIds.includes(input.customerId)) {
          throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'Clients can only subscribe to their own appointment events'
          });
        }
        
        // Log subscription start
        logger.info('User subscribed to appointment events', {
          userId: ctx.userId,
          isAdmin,
          isArtist,
          isCustomer,
          artistId: input?.artistId,
          customerId: input?.customerId
        });
      } catch (error) {
        logger.error('Error in appointment events subscription', { 
          error: error instanceof Error ? error.message : 'Unknown error', 
          userId: ctx.userId 
        });
        throw error instanceof TRPCError ? error : new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to initialize appointment events subscription',
          cause: error
        });
      }

      // Create unique subscriber ID to prevent memory leaks
      const subscriberId = `appointment-${ctx.userId}-${Date.now()}`;
      
      // Set up rate limiting
      const maxEventsPerMinute = 60;
      let eventCount = 0;
      let lastRateLimitReset = Date.now();
      
      // Define sensitive fields to remove based on role
      const sensitiveFields = isAdmin ? [] : [
        'internalNotes',
        'paymentDetails',
        'adminComments',
        'financialData',
        'sensitiveCustomerInfo'
      ];

      // Create observable for subscription
      return observable<AppointmentEvent>((emit) => {
        const onAppointmentEvent = (data: AppointmentEvent) => {
          try {
            // Apply rate limiting
            const now = Date.now();
            if (now - lastRateLimitReset > 60000) {
              eventCount = 0;
              lastRateLimitReset = now;
            }
            
            if (eventCount >= maxEventsPerMinute) {
              logger.warn('Rate limit exceeded for appointment events', { userId: ctx.userId });
              return;
            }
            
            eventCount++;
            
            // Validate event data
            if (!data?.id) {
              logger.warn('Received invalid appointment event data', { eventData: data });
              return;
            }
            
            // Filter by artistId if provided
            if (input?.artistId && data.data.artistId !== input.artistId) {
              return;
            }

            // Filter by customerId if provided
            if (input?.customerId && data.data.customerId !== input.customerId) {
              return;
            }
            
            // Apply business rules based on user role
            if (isAdmin) {
              // Admins see all appointments
              emit.next(data);
            } else if (isArtist && data.data.artistId === artistId) {
              // Artists see appointments assigned to them
              const sanitizedData = sanitizeEventData(data, sensitiveFields);
              emit.next(sanitizedData);
            } else if (isCustomer && customerIds.includes(data.data.customerId ?? '')) {
              // Clients only see their own appointments
              const sanitizedData = sanitizeEventData(data, sensitiveFields);
              emit.next(sanitizedData);
            }
          } catch (error) {
            logger.error('Error processing appointment event', { 
              error: error instanceof Error ? error.message : 'Unknown error',
              eventId: data.id 
            });
          }
        };

        // Subscribe to appointment events
        const unsubscribe = eventManager.on('appointment', subscriberId, onAppointmentEvent);

        // Cleanup when client unsubscribes
        return () => {
          unsubscribe();
          logger.debug('User unsubscribed from appointment events', { userId: ctx.userId });
        };
      });
    }),

  // ===========================================================================
  // CUSTOMER EVENTS SUBSCRIPTION (ADMIN ONLY)
  // ===========================================================================
  customerEvents: adminProcedure
    .input(CustomerFilterSchema)
    .subscription(async ({ input, ctx }) => {
      try {
        // Verify the user is truly an admin (since adminProcedure already checks auth)
        const user = await prisma.user.findUnique({
          where: { id: ctx.userId },
          select: { role: true }
        });
        
        // Double-check admin role for sensitive customer data
        if (user?.role !== UserRole.ADMIN) {
          throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'Only administrators can access customer events'
          });
        }
        
        // Log subscription start
        logger.info('Admin subscribed to customer events', {
          userId: ctx.userId,
          customerId: input?.customerId
        });
      } catch (error) {
        logger.error('Error in customer events subscription', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          userId: ctx.userId 
        });
        throw error instanceof TRPCError ? error : new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to initialize customer events subscription',
          cause: error
        });
      }

      // Create unique subscriber ID to prevent memory leaks
      const subscriberId = `customer-${ctx.userId}-${Date.now()}`;
      
      // Set up rate limiting
      const maxEventsPerMinute = 60;
      let eventCount = 0;
      let lastRateLimitReset = Date.now();

      // Create observable for subscription
      return observable<CustomerEvent>((emit) => {
        const onCustomerEvent = (data: CustomerEvent) => {
          try {
            // Apply rate limiting
            const now = Date.now();
            if (now - lastRateLimitReset > 60000) {
              eventCount = 0;
              lastRateLimitReset = now;
            }
            
            if (eventCount >= maxEventsPerMinute) {
              logger.warn('Rate limit exceeded for customer events', { userId: ctx.userId });
              return;
            }
            
            eventCount++;
            
            // Validate event data
            if (!data?.id) {
              logger.warn('Received invalid customer event data', { eventData: data });
              return;
            }
            
            // Filter by customerId if provided
            if (input?.customerId && data.id !== input.customerId) {
              return;
            }

            // Apply GDPR and data protection rules
            // Filter out any sensitive data not needed for admin operations
            
            // Emit the customer event
            emit.next(data);
          } catch (error) {
            logger.error('Error processing customer event', { 
              error: error instanceof Error ? error.message : 'Unknown error',
              eventId: data.id 
            });
          }
        };

        // Subscribe to customer events
        const unsubscribe = eventManager.on('customer', subscriberId, onCustomerEvent);

        // Cleanup when client unsubscribes
        return () => {
          unsubscribe();
          logger.debug('Admin unsubscribed from customer events', { userId: ctx.userId });
        };
      });
    }),

  // ===========================================================================
  // GALLERY EVENTS SUBSCRIPTION (PUBLIC)
  // ===========================================================================
  galleryEvents: publicProcedure
    .input(GalleryFilterSchema)
    .subscription(({ input, ctx }) => {
      // Prepare connection information for logging
      const userInfo = ctx.userId ? `User: ${ctx.userId}` : 'Anonymous user';
      const clientInfo = {
        userId: ctx.userId ?? 'anonymous',
        timestamp: new Date().toISOString(),
        subscriptionType: 'gallery_events',
        limit: input?.limit ?? 10,
        categories: input?.categories ?? [],
      };
      
      // Log the connection with structured data for analytics and security
      logger.info(`Public gallery events subscription started: ${userInfo}`, clientInfo);
      
      // Create unique subscriber ID to prevent memory leaks
      const subscriberId = `gallery-${ctx.userId ?? 'anonymous'}-${Date.now()}`;
      
      // Set up rate limiting
      const maxEventsPerMinute = 60;
      let eventCount = 0;
      let lastRateLimitReset = Date.now();
      
      // Create observable for subscription with proper rate limiting and security
      return observable<GalleryEvent>((emit) => {
        const onGalleryEvent = (data: GalleryEvent) => {
          try {
            // Apply rate limiting to prevent DoS
            const now = Date.now();
            if (now - lastRateLimitReset > 60000) {
              // Reset counter every minute
              eventCount = 0;
              lastRateLimitReset = now;
            }
            
            if (eventCount >= maxEventsPerMinute) {
              logger.warn('Gallery event rate limit exceeded for client', clientInfo);
              return; // Skip this event due to rate limiting
            }
            
            eventCount++;
            
            // Content filtering - only send approved and non-sensitive content
            if (data.data.isApproved !== true && data.type !== 'approved') {
              return; // Don't send unapproved content
            }
            
            // Category filtering if specified
            if (input?.categories?.length && data.data.category) {
              if (!input.categories.includes(String(data.data.category))) {
                return; // Skip events not matching requested categories
              }
            }
            
            // Sanitize data to prevent leaking internal information
            const sanitizedData: GalleryEvent = {
              id: data.id,
              type: data.type,
              data: {
                id: data.data.id,
                title: data.data.title ?? "",
                url: data.data.url ?? "",
                thumbUrl: data.data.thumbUrl ?? "",
                createdAt: data.data.createdAt ?? new Date(),
                // Additional safe fields that can be exposed to public
                category: data.data.category ?? null,
                tags: data.data.tags ?? null,
                dimensions: data.data.dimensions ?? null,
                // Add a placeholder field to ensure proper record type
                otherInfo: {} as Record<string, unknown>
              }
            };
            
            // Send sanitized event to client
            emit.next(sanitizedData);
          } catch (error) {
            logger.error('Error processing public gallery event', {
              error: error instanceof Error ? error.message : 'Unknown error',
              eventId: data.id,
              ...clientInfo
            });
          }
        };

        // Subscribe to gallery events
        const unsubscribe = eventManager.on('gallery', subscriberId, onGalleryEvent);

        // Cleanup when client unsubscribes
        return () => {
          unsubscribe();
          
          // Log unsubscription
          logger.debug('Public user unsubscribed from gallery events', clientInfo);
          
          // Record unsubscribe event for analytics - using logs for now
          logger.info('Gallery subscription ended', {
            eventType: 'subscription_end',
            eventCategory: 'realtime',
            eventName: 'gallery_subscription',
            userId: ctx.userId,
            metadata: {
              ...clientInfo,
              duration: Date.now() - new Date(clientInfo.timestamp).getTime(),
              eventsReceived: eventCount,
            }
          });
        };
      });
    }),

  // ===========================================================================
  // GALLERY ADMIN EVENTS SUBSCRIPTION (ADMIN ONLY)
  // ===========================================================================
  galleryAdminEvents: adminProcedure
    .subscription(async ({ ctx }) => {
      try {
        // Verify admin permissions for gallery management
        const hasGalleryPermissions = await validateUserPermissions(
          ctx.userId, 
          ['MANAGE_GALLERY']
        );
        
        if (!hasGalleryPermissions) {
          throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'You do not have permission to access gallery admin events'
          });
        }
        
        // Log subscription start
        logger.info('Admin subscribed to gallery admin events', { userId: ctx.userId });
      } catch (error) {
        logger.error('Error in gallery admin events subscription', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          userId: ctx.userId 
        });
        throw error instanceof TRPCError ? error : new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to initialize gallery admin events subscription',
          cause: error
        });
      }

      // Create unique subscriber ID to prevent memory leaks
      const subscriberId = `gallery-admin-${ctx.userId}-${Date.now()}`;
      
      // Create observable for subscription
      return observable<GalleryEvent>((emit) => {
        const onGalleryEvent = (data: GalleryEvent) => {
          try {
            // Admin sees all gallery events, including unapproved and internal ones
            emit.next(data);
            
            // Log sensitive operations for audit purposes
            if (data.type === 'deleted' || data.type === 'approved') {
              logger.info('Admin observed gallery moderation event', {
                userId: ctx.userId,
                eventType: data.type,
                galleryItemId: data.id
              });
            }
          } catch (error) {
            logger.error('Error processing gallery admin event', { 
              error: error instanceof Error ? error.message : 'Unknown error',
              eventId: data.id 
            });
          }
        };

        // Subscribe to gallery events
        const unsubscribe = eventManager.on('gallery', subscriberId, onGalleryEvent);

        // Cleanup when client unsubscribes
        return () => {
          unsubscribe();
          logger.debug('Admin unsubscribed from gallery admin events', { userId: ctx.userId });
        };
      });
    }),

  // ===========================================================================
  // DASHBOARD ACTIVITY STREAM (ADMIN ONLY)
  // ===========================================================================
  dashboardActivity: adminProcedure
    .subscription(async ({ ctx }) => {
      try {
        // Verify the user is truly an admin with dashboard access
        const hasAdminPermissions = await validateUserPermissions(
          ctx.userId, 
          ['MANAGE_USERS', 'MANAGE_BOOKINGS']
        );
        
        if (!hasAdminPermissions) {
          throw new TRPCError({
            code: 'FORBIDDEN',
            message: 'You do not have permission to access dashboard activity stream'
          });
        }
        
        // Log subscription start
        logger.info('Admin subscribed to dashboard activity stream', { userId: ctx.userId });
      } catch (error) {
        logger.error('Error in dashboard activity subscription', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          userId: ctx.userId 
        });
        throw error instanceof TRPCError ? error : new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to initialize dashboard activity subscription',
          cause: error
        });
      }
      
      // Create unique subscriber ID to prevent memory leaks
      const dashboardId = `dashboard-${ctx.userId}-${Date.now()}`;

      // Create a generator-based subscription for more complex event handling
      return observable<DashboardActivityEvent>((emit) => {
        // Combined event handler for all activity types
        const onActivity = (
          type: string,
          data: BookingEvent | AppointmentEvent | CustomerEvent | GalleryEvent
        ) => {
          try {
            // Create the dashboard activity event with correct type casting
            const activityEvent: DashboardActivityEvent = {
              type,
              data: data as BookingEvent | AppointmentEvent | CustomerEvent | GalleryEvent,
              timestamp: new Date(),
            };
            
            // Emit the event to the subscriber
            emit.next(activityEvent);
            
            // Record dashboard view activity for analytics
            logger.info('Dashboard activity recorded', {
              type: 'dashboard_view',
              userId: ctx.userId,
              eventType: type,
              eventId: typeof data.id === 'number' ? data.id.toString() : data.id
            });
          } catch (error) {
            logger.error('Error processing dashboard activity', { 
              error: error instanceof Error ? error.message : 'Unknown error',
              eventType: type,
              userId: ctx.userId
            });
          }
        };

        // Subscribe to all event types for dashboard with type-specific handlers
        const bookingSubscriberId = `${dashboardId}-booking`;
        const appointmentSubscriberId = `${dashboardId}-appointment`;
        const customerSubscriberId = `${dashboardId}-customer`;
        const gallerySubscriberId = `${dashboardId}-gallery`;
        
        const onBooking = (data: BookingEvent) => onActivity('booking', data);
        const onAppointment = (data: AppointmentEvent) => onActivity('appointment', data);
        const onCustomer = (data: CustomerEvent) => onActivity('customer', data);
        const onGallery = (data: GalleryEvent) => onActivity('gallery', data);

        const unsubscribeBooking = eventManager.on('booking', bookingSubscriberId, onBooking);
        const unsubscribeAppointment = eventManager.on('appointment', appointmentSubscriberId, onAppointment);
        const unsubscribeCustomer = eventManager.on('customer', customerSubscriberId, onCustomer);
        const unsubscribeGallery = eventManager.on('gallery', gallerySubscriberId, onGallery);

        // Cleanup when client unsubscribes
        return () => {
          unsubscribeBooking();
          unsubscribeAppointment();
          unsubscribeCustomer();
          unsubscribeGallery();
          logger.debug('Admin unsubscribed from dashboard activity stream', { userId: ctx.userId });
        };
      });
    }),
    
  // ===========================================================================
  // SUBSCRIPTION STATS (ADMIN ONLY) - FOR MONITORING
  // ===========================================================================
  subscriptionStats: adminProcedure
    .query(async ({ ctx }) => {
      try {
        // Simplified permission check since adminProcedure already checks for admin role
        // Get subscription stats for monitoring
        const stats = eventManager.getStats();
        
        return {
          success: true,
          stats,
          timestamp: new Date(),
        };
      } catch (error) {
        logger.error('Error getting subscription stats', { 
          error: error instanceof Error ? error.message : 'Unknown error',
          userId: ctx.userId 
        });
        throw error instanceof TRPCError ? error : new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to get subscription stats',
          cause: error
        });
      }
    }),
});

// =============================================================================
// HANDLING CLEANUP ON SERVER SHUTDOWN
// =============================================================================

// Handle process termination to clean up event listeners and prevent memory leaks
// This is especially important for production environments
if (process.env.NODE_ENV === 'production') {
  const cleanup = () => {
    try {
      eventManager.removeAllListeners();
      logger.info('Event listeners cleaned up on server shutdown');
    } catch (err) {
      logger.error('Error cleaning up event listeners', {
        error: err instanceof Error ? err.message : 'Unknown error'
      });
    }
  };
  
  // Handle normal exit
  process.on('exit', cleanup);
  
  // Handle CTRL+C
  process.on('SIGINT', () => {
    cleanup();
    process.exit(0);
  });
  
  // Handle kill command
  process.on('SIGTERM', () => {
    cleanup();
    process.exit(0);
  });
  
  // Handle uncaught exceptions (should be rare in production)
  process.on('uncaughtException', (err) => {
    logger.error('Uncaught exception in subscription system', {
      error: err.message,
      stack: err.stack
    });
    cleanup();
    
    // Give chance for logs to be written before exiting
    setTimeout(() => {
      process.exit(1);
    }, 500);
  });
}/**
 * Cal.com-based Appointments Router
 * 
 * This router interfaces with Cal.com to manage appointments instead of
 * maintaining a separate appointment system. It maps Cal.com bookings
 * to our appointment interfaces for backward compatibility.
 */

import { z } from 'zod';
import { TRPCError } from '@trpc/server';
import { router, protectedProcedure, adminProcedure } from '../procedures';
import { AppointmentStatus } from '@prisma/client';
import { handleRouterError } from '../utils/router-error-handler';
import { 
  getCalBookings, 
  getCalBookingByUid, 
  updateCalBookingStatus, 
  rescheduleCalBooking 
} from '@/lib/cal/api';

export const appointmentsRouter = router({
  /**
   * Get all appointments with filtering
   * This now retrieves data from Cal.com and maps it to our appointment interface
   */
  getAll: protectedProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).default(50),
        cursor: z.string().nullish(),
        status: z.nativeEnum(AppointmentStatus).optional(),
        customerId: z.string().optional(),
        startDate: z
          .string()
          .datetime()
          .optional()
          .transform((val) => (val ? new Date(val) : undefined)),
        endDate: z
          .string()
          .datetime()
          .optional()
          .transform((val) => (val ? new Date(val) : undefined)),
      })
    )
    .query(async ({ input }) => {
      try {
        // Get bookings from Cal.com
        const calBookings = await getCalBookings({
          limit: input.limit,
          status: input.status,
        });

        // Find bookings that match our filter criteria
        const filteredBookings = calBookings.filter(booking => {
          // Filter by status if provided
          if (input.status && booking.status !== input.status) {
            return false;
          }

          // Filter by customer if provided
          if (input.customerId && booking.attendees?.[0]?.email) {
            // We'd need to match by email since Cal.com uses email as identifier
            // This would require a separate query to match customer ID to email
            // For now, we'll just skip this filter
          }

          // Filter by date range if provided
          if (input.startDate && new Date(booking.startTime) < input.startDate) {
            return false;
          }
          if (input.endDate && new Date(booking.startTime) > input.endDate) {
            return false;
          }

          return true;
        });

        // Handle pagination via cursors
        let startIndex = 0;
        if (input.cursor) {
          const cursorIndex = filteredBookings.findIndex(b => b.uid === input.cursor);
          if (cursorIndex > -1) {
            startIndex = cursorIndex + 1;
          }
        }

        // Get the page of results
        const paginatedBookings = filteredBookings.slice(startIndex, startIndex + input.limit + 1);
        
        // Set up next cursor
        let nextCursor: string | undefined;
        if (paginatedBookings.length > input.limit) {
          const nextItem = paginatedBookings.pop();
          nextCursor = nextItem?.uid;
        }

        // Transform Cal.com bookings to our appointment interface
        const transformedAppointments = paginatedBookings.map(booking => {
          const attendee = booking.attendees?.[0];
          const startTime = new Date(booking.startTime);
          const endTime = new Date(booking.endTime);
          
          // Calculate duration
          const duration = Math.round((endTime.getTime() - startTime.getTime()) / (1000 * 60));
          
          return {
            id: booking.uid,
            customerId: attendee?.email ?? '',
            clientName: attendee?.name ?? 'Unknown',
            clientEmail: attendee?.email ?? '',
            clientPhone: '',
            appointmentDate: startTime.toISOString(),
            duration: duration > 0 ? duration : 60,
            status: booking.status as AppointmentStatus,
            depositPaid: booking.payment?.status === 'COMPLETED',
            depositAmount: booking.payment?.amount ?? 0,
            totalPrice: booking.payment?.amount ?? 0,
            tattooStyle: '',
            description: booking.description ?? booking.title,
            location: booking.location ?? '',
            size: '',
            createdAt: booking.createdAt,
            updatedAt: booking.updatedAt,
          };
        });

        return {
          items: transformedAppointments,
          nextCursor,
        };
      } catch (error) {
        return handleRouterError(error, {
          operation: 'query',
          procedureName: 'getAll',
          routerName: 'appointments',
          input
        });
      }
    }),

  /**
   * Create a new appointment using Cal.com
   * Note: This is not fully implemented as it would require creating
   * a Cal.com booking via their API, which is not available here.
   * Users should book through Cal.com directly.
   */
  create: adminProcedure
    .input(
      z.object({
        customerId: z.string(),
        artistId: z.string().optional(),
        title: z.string().optional(),
        appointmentDate: z.date(),
        duration: z.number().min(15).default(120),
        status: z.nativeEnum(AppointmentStatus).default(AppointmentStatus.SCHEDULED),
        depositAmount: z.number().min(0).default(0),
        totalPrice: z.number().min(0).default(0),
        description: z.string().optional(),
        location: z.string().optional(),
      })
    )
    .mutation(async () => {
      throw new TRPCError({
        code: 'NOT_IMPLEMENTED',
        message: 'Direct appointment creation is not supported. Please use Cal.com to create appointments.',
      });
    }),

  /**
   * Update an appointment
   * This now updates the Cal.com booking
   */
  update: adminProcedure
    .input(
      z.object({
        id: z.string(),
        title: z.string().optional(),
        appointmentDate: z.date().optional(),
        duration: z.number().min(15).optional(),
        status: z.nativeEnum(AppointmentStatus).optional(),
        depositAmount: z.number().min(0).optional(),
        totalPrice: z.number().min(0).optional(),
        description: z.string().optional(),
        location: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      try {
        const { id, appointmentDate, duration, status } = input;
        
        // Get the booking from Cal.com
        await getCalBookingByUid(id);
        
        // Update status if provided
        if (status) {
          const calStatus = status === AppointmentStatus.CANCELLED ? 'cancelled' : 
                           status === AppointmentStatus.CONFIRMED ? 'accepted' : 'accepted';
          await updateCalBookingStatus(id, calStatus as 'cancelled' | 'accepted');
        }
        
        // Reschedule if new date is provided
        if (appointmentDate) {
          const endTime = new Date(appointmentDate);
          endTime.setMinutes(endTime.getMinutes() + (duration ?? 60));
          
          await rescheduleCalBooking(id, {
            start: appointmentDate.toISOString(),
            end: endTime.toISOString(),
          });
        }
        
        // Get updated booking
        const updatedBooking = await getCalBookingByUid(id);
        const attendee = updatedBooking.attendees?.[0];
        const startTime = new Date(updatedBooking.startTime);
        const endTime = new Date(updatedBooking.endTime);
        
        // Calculate duration
        const updatedDuration = Math.round((endTime.getTime() - startTime.getTime()) / (1000 * 60));
        
        return {
          id: updatedBooking.uid,
          customerId: attendee?.email ?? '',
          clientName: attendee?.name ?? 'Unknown',
          clientEmail: attendee?.email ?? '',
          clientPhone: '',
          appointmentDate: startTime.toISOString(),
          duration: updatedDuration > 0 ? updatedDuration : 60,
          status: updatedBooking.status as AppointmentStatus,
          depositPaid: updatedBooking.payment?.status === 'COMPLETED',
          depositAmount: updatedBooking.payment?.amount ?? 0,
          totalPrice: updatedBooking.payment?.amount ?? 0,
          tattooStyle: '',
          description: updatedBooking.description ?? updatedBooking.title,
          location: updatedBooking.location ?? '',
          size: '',
          createdAt: updatedBooking.createdAt,
          updatedAt: updatedBooking.updatedAt,
        };
      } catch (error) {
        return handleRouterError(error, {
          operation: 'mutation',
          procedureName: 'update',
          routerName: 'appointments',
          input
        });
      }
    }),

  /**
   * Delete an appointment
   * This now cancels the Cal.com booking
   */
  delete: adminProcedure
    .input(
      z.object({
        id: z.string(),
      })
    )
    .mutation(async ({ input }) => {
      try {
        // Cancel the booking in Cal.com
        await updateCalBookingStatus(input.id, 'cancelled');
        
        return { success: true };
      } catch (error) {
        return handleRouterError(error, {
          operation: 'mutation',
          procedureName: 'delete',
          routerName: 'appointments',
          input
        });
      }
    }),
});
/**
 * Dashboard Activity tRPC Router
 *
 * Provides type-safe procedures for activity tracking and notifications within the dashboard.
 * Split from dashboard-router.ts for better maintainability and organization.
 */

import { z } from 'zod';
import { logger } from '@/lib/logger';
import { router, publicProcedure, protectedProcedure, adminProcedure } from '@/lib/trpc/procedures';
import { prisma } from '@/lib/db/prisma';
import { TRPCError } from '@trpc/server';
import type { Prisma } from '@prisma/client';

// Activity and notification schemas using Zod
const RecentActivitySchema = z.object({
  limit: z.number().min(1).max(100).default(20),
  includeSystem: z.boolean().default(false),
  types: z.array(z.string()).optional(),
});

const ActivityFilterSchema = z.object({
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  types: z.array(z.enum(['contact', 'customer', 'booking', 'payment'])).optional(),
  limit: z.number().min(1).max(100).default(50),
  cursor: z.string().optional(),
});

// Type for activity items - this is a UI type, not a database model
type ActivityItem = {
  id: string;
  type: 'contact' | 'customer' | 'booking' | 'payment';
  title: string;
  message: string;
  time: string;
  timeAgo: string;
  link: string;
  data: Record<string, unknown>;
};

// Type for notification-like items derived from existing models
type NotificationItem = {
  id: string;
  type: 'contact' | 'customer' | 'booking' | 'payment';
  title: string;
  message: string;
  time: string;
  timeAgo: string;
  priority: 'low' | 'medium' | 'high';
  read: boolean;
  link: string;
  data: Record<string, unknown>;
};

/**
 * Helper function to get human-readable time ago string
 */
function getTimeAgo(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / (1000 * 60));
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffMins < 1) {
    return 'Just now';
  } else if (diffMins < 60) {
    return `${diffMins} minute${diffMins === 1 ? '' : 's'} ago`;
  } else if (diffHours < 24) {
    return `${diffHours} hour${diffHours === 1 ? '' : 's'} ago`;
  } else if (diffDays < 7) {
    return `${diffDays} day${diffDays === 1 ? '' : 's'} ago`;
  } else {
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined,
    });
  }
}

export const activityRouter = router({
  getRecentActivity: publicProcedure.input(RecentActivitySchema).query(async ({ input }) => {
    const { limit } = input;

    try {
      // Since bookings and appointments are handled by Cal.com integration,
      // we'll focus on internal activities like contact forms, customer additions, etc.
      
      // Get recent contacts
      const recentContacts = await prisma.contact.findMany({
        take: Math.ceil(limit / 3), // Split between contacts, customers, and payments
        orderBy: {
          createdAt: 'desc',
        },
        select: {
          id: true,
          name: true,
          email: true,
          subject: true,
          createdAt: true,
        },
      });

      // Get recent customers
      const recentCustomers = await prisma.customer.findMany({
        take: Math.ceil(limit / 3),
        orderBy: {
          createdAt: 'desc',
        },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          createdAt: true,
        },
      });

      // Get recent payments
      const recentPayments = await prisma.payment.findMany({
        take: Math.ceil(limit / 3),
        orderBy: {
          createdAt: 'desc',
        },
        select: {
          id: true,
          amount: true,
          currency: true,
          status: true,
          customerName: true,
          customerEmail: true,
          serviceName: true,
          createdAt: true,
        },
      });

      // Transform into activity items
      const activityItems: ActivityItem[] = [
        ...recentContacts.map((contact) => ({
          id: `contact-${contact.id}`,
          type: 'contact' as const,
          title: 'New Contact Message',
          message: `${contact.name} sent a message: ${contact.subject ?? 'No subject'}`,
          time: contact.createdAt.toISOString(),
          timeAgo: getTimeAgo(contact.createdAt),
          link: `/admin/contacts?id=${contact.id}`,
          data: {
            contactId: contact.id,
            contactName: contact.name,
            contactEmail: contact.email,
          },
        })),
        ...recentCustomers.map((customer) => ({
          id: `customer-${customer.id}`,
          type: 'customer' as const,
          title: 'New Customer',
          message: `${customer.firstName} ${customer.lastName} joined`,
          time: customer.createdAt.toISOString(),
          timeAgo: getTimeAgo(customer.createdAt),
          link: `/admin/customers?id=${customer.id}`,
          data: {
            customerId: customer.id,
            customerName: `${customer.firstName} ${customer.lastName}`,
            customerEmail: customer.email,
          },
        })),
        ...recentPayments.map((payment) => ({
          id: `payment-${payment.id}`,
          type: 'payment' as const,
          title: 'Payment Received',
          message: `${payment.customerName} paid ${payment.currency} ${payment.amount} for ${payment.serviceName ?? 'Service'}`,
          time: payment.createdAt.toISOString(),
          timeAgo: getTimeAgo(payment.createdAt),
          link: `/admin/payments?id=${payment.id}`,
          data: {
            paymentId: payment.id,
            amount: payment.amount,
            currency: payment.currency,
            status: payment.status,
          },
        })),
      ]
        .sort((a, b) => new Date(b.time).getTime() - new Date(a.time).getTime())
        .slice(0, limit);

      return {
        activities: activityItems,
        total: activityItems.length,
      };
    } catch (error) {
      void logger.error('Error fetching recent activity:', error);
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Failed to fetch recent activity',
        cause: error,
      });
    }
  }),

  getNotifications: publicProcedure
    .input(z.object({
      limit: z.number().min(1).max(100).default(10),
      unreadOnly: z.boolean().default(false),
      priority: z.enum(['low', 'medium', 'high']).optional(),
    }))
    .query(async ({ input }) => {
      const { limit } = input;

      try {
        // Since we don't have a notifications table, we'll create "notifications" 
        // from recent unhandled contacts and pending payments
        
        // Get recent unhandled contacts (as high priority notifications)
        const recentContacts = await prisma.contact.findMany({
          orderBy: { createdAt: 'desc' },
          take: Math.ceil(limit / 2),
          select: {
            id: true,
            name: true,
            email: true,
            subject: true,
            message: true,
            createdAt: true,
          },
        });

        // Get pending payments (as medium priority notifications)
        const pendingPayments = await prisma.payment.findMany({
          where: {
            status: 'PENDING',
          },
          orderBy: { createdAt: 'desc' },
          take: Math.ceil(limit / 2),
          select: {
            id: true,
            amount: true,
            currency: true,
            customerName: true,
            customerEmail: true,
            serviceName: true,
            createdAt: true,
          },
        });

        // Transform into notification items
        const notifications: NotificationItem[] = [
          ...recentContacts.map((contact) => ({
            id: `contact-${contact.id}`,
            type: 'contact' as const,
            title: 'New Contact Message',
            message: `${contact.name}: ${contact.subject ?? 'New message'}`,
            time: contact.createdAt.toISOString(),
            timeAgo: getTimeAgo(contact.createdAt),
            priority: 'high' as const,
            read: false, // Contacts are always "unread" since we don't track this
            link: `/admin/contacts?id=${contact.id}`,
            data: {
              contactId: contact.id,
              preview: contact.message.substring(0, 100),
            },
          })),
          ...pendingPayments.map((payment) => ({
            id: `payment-${payment.id}`,
            type: 'payment' as const,
            title: 'Pending Payment',
            message: `${payment.customerName} - ${payment.currency} ${payment.amount}`,
            time: payment.createdAt.toISOString(),
            timeAgo: getTimeAgo(payment.createdAt),
            priority: 'medium' as const,
            read: false, // Pending payments are "unread"
            link: `/admin/payments?id=${payment.id}`,
            data: {
              paymentId: payment.id,
              amount: payment.amount,
              currency: payment.currency,
            },
          })),
        ]
          .sort((a, b) => new Date(b.time).getTime() - new Date(a.time).getTime())
          .slice(0, limit);

        return {
          notifications,
          unreadCount: notifications.filter(n => !n.read).length,
          total: notifications.length,
        };
      } catch (error) {
        void logger.error('Error fetching notifications:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch notifications',
          cause: error,
        });
      }
    }),

  // Get activity statistics
  getActivityStats: protectedProcedure
    .input(z.object({
      timeRange: z.enum(['day', 'week', 'month', 'year']).default('week'),
    }))
    .query(async ({ input }) => {
      try {
        const now = new Date();
        let startDate: Date;

        switch (input.timeRange) {
          case 'day':
            startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            break;
          case 'week':
            startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7);
            break;
          case 'month':
            startDate = new Date(now.getFullYear(), now.getMonth() - 1, now.getDate());
            break;
          case 'year':
            startDate = new Date(now.getFullYear() - 1, now.getMonth(), now.getDate());
            break;
        }

        // Get counts in parallel
        const [contactsCount, customersCount, paymentsCount, bookingsCount] = await Promise.all([
          prisma.contact.count({
            where: {
              createdAt: {
                gte: startDate,
              },
            },
          }),
          prisma.customer.count({
            where: {
              createdAt: {
                gte: startDate,
              },
            },
          }),
          prisma.payment.count({
            where: {
              createdAt: {
                gte: startDate,
              },
            },
          }),
          prisma.calBooking.count({
            where: {
              createdAt: {
                gte: startDate,
              },
            },
          }),
        ]);

        return {
          timeRange: input.timeRange,
          startDate: startDate.toISOString(),
          stats: {
            contacts: contactsCount,
            customers: customersCount,
            payments: paymentsCount,
            bookings: bookingsCount,
            total: contactsCount + customersCount + paymentsCount + bookingsCount,
          },
        };
      } catch (error) {
        void logger.error('Error fetching activity stats:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch activity statistics',
          cause: error,
        });
      }
    }),

  // Get filtered activity with pagination
  getFilteredActivity: protectedProcedure
    .input(ActivityFilterSchema)
    .query(async ({ input }) => {
      try {
        const { startDate, endDate, types, limit } = input;

        // Build date filter
        const dateFilter: Prisma.DateTimeFilter = {};
        if (startDate) {
          dateFilter.gte = new Date(startDate);
        }
        if (endDate) {
          dateFilter.lte = new Date(endDate);
        }

        // Initialize arrays for each type
        const activities: ActivityItem[] = [];

        // Fetch data based on selected types (or all if none specified)
        const shouldFetchContacts = !types || types.includes('contact');
        const shouldFetchCustomers = !types || types.includes('customer');
        const shouldFetchPayments = !types || types.includes('payment');
        const shouldFetchBookings = !types || types.includes('booking');

        // Fetch each type in parallel
        const [contacts, customers, payments, bookings] = await Promise.all([
          shouldFetchContacts
            ? prisma.contact.findMany({
                where: { createdAt: dateFilter },
                orderBy: { createdAt: 'desc' },
                take: Math.ceil(limit / 4),
                select: {
                  id: true,
                  name: true,
                  email: true,
                  subject: true,
                  createdAt: true,
                },
              })
            : [],
          shouldFetchCustomers
            ? prisma.customer.findMany({
                where: { createdAt: dateFilter },
                orderBy: { createdAt: 'desc' },
                take: Math.ceil(limit / 4),
                select: {
                  id: true,
                  firstName: true,
                  lastName: true,
                  email: true,
                  createdAt: true,
                },
              })
            : [],
          shouldFetchPayments
            ? prisma.payment.findMany({
                where: { createdAt: dateFilter },
                orderBy: { createdAt: 'desc' },
                take: Math.ceil(limit / 4),
                select: {
                  id: true,
                  amount: true,
                  currency: true,
                  status: true,
                  customerName: true,
                  serviceName: true,
                  createdAt: true,
                },
              })
            : [],
          shouldFetchBookings
            ? prisma.calBooking.findMany({
                where: { createdAt: dateFilter },
                orderBy: { createdAt: 'desc' },
                take: Math.ceil(limit / 4),
                select: {
                  id: true,
                  title: true,
                  attendeeName: true,
                  attendeeEmail: true,
                  serviceName: true,
                  startTime: true,
                  status: true,
                  createdAt: true,
                },
              })
            : [],
        ]);

        // Transform contacts
        if (contacts.length > 0) {
          activities.push(
            ...contacts.map((contact) => ({
              id: `contact-${contact.id}`,
              type: 'contact' as const,
              title: 'New Contact Message',
              message: `${contact.name} sent a message: ${contact.subject ?? 'No subject'}`,
              time: contact.createdAt.toISOString(),
              timeAgo: getTimeAgo(contact.createdAt),
              link: `/admin/contacts?id=${contact.id}`,
              data: {
                contactId: contact.id,
                contactName: contact.name,
                contactEmail: contact.email,
              },
            }))
          );
        }

        // Transform customers
        if (customers.length > 0) {
          activities.push(
            ...customers.map((customer) => ({
              id: `customer-${customer.id}`,
              type: 'customer' as const,
              title: 'New Customer',
              message: `${customer.firstName} ${customer.lastName} joined`,
              time: customer.createdAt.toISOString(),
              timeAgo: getTimeAgo(customer.createdAt),
              link: `/admin/customers?id=${customer.id}`,
              data: {
                customerId: customer.id,
                customerName: `${customer.firstName} ${customer.lastName}`,
                customerEmail: customer.email,
              },
            }))
          );
        }

        // Transform payments
        if (payments.length > 0) {
          activities.push(
            ...payments.map((payment) => ({
              id: `payment-${payment.id}`,
              type: 'payment' as const,
              title: 'Payment Activity',
              message: `${payment.customerName} - ${payment.currency} ${payment.amount} (${payment.status})`,
              time: payment.createdAt.toISOString(),
              timeAgo: getTimeAgo(payment.createdAt),
              link: `/admin/payments?id=${payment.id}`,
              data: {
                paymentId: payment.id,
                amount: payment.amount,
                currency: payment.currency,
                status: payment.status,
              },
            }))
          );
        }

        // Transform bookings
        if (bookings.length > 0) {
          activities.push(
            ...bookings.map((booking) => ({
              id: `booking-${booking.id}`,
              type: 'booking' as const,
              title: 'Booking Activity',
              message: `${booking.attendeeName} booked ${booking.serviceName}`,
              time: booking.createdAt.toISOString(),
              timeAgo: getTimeAgo(booking.createdAt),
              link: `/admin/bookings?id=${booking.id}`,
              data: {
                bookingId: booking.id,
                attendeeName: booking.attendeeName,
                serviceName: booking.serviceName,
                startTime: booking.startTime.toISOString(),
                status: booking.status,
              },
            }))
          );
        }

        // Sort by time and limit
        const sortedActivities = activities
          .sort((a, b) => new Date(b.time).getTime() - new Date(a.time).getTime())
          .slice(0, limit);

        return {
          activities: sortedActivities,
          total: sortedActivities.length,
          hasMore: sortedActivities.length >= limit,
        };
      } catch (error) {
        void logger.error('Error fetching filtered activity:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch filtered activity',
          cause: error,
        });
      }
    }),
});/**
 * Dashboard Stats tRPC Router
 *
 * Provides type-safe procedures for dashboard statistics and summary data.
 * Split from dashboard-router.ts for better maintainability and organization.
 */

import { router, publicProcedure } from '@/lib/trpc/procedures';
import { prisma } from '@/lib/db/prisma';
import { formatDateRange } from '@/lib/utils/date-format';
import { Prisma, AppointmentStatus } from '@prisma/client';
import { z } from 'zod';

// Stats filter schema using Zod
const StatsFilterSchema = z.object({
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  status: z.string().optional(),
  period: z.enum(['week', 'month', 'quarter', 'year']).optional(),
  compareWithPrevious: z.boolean().optional(),
});
import { handleRouterError } from '../../utils/router-error-handler';

/**
 * Helper function to build type-safe date filters for appointment queries
 * Prevents Prisma exactOptionalPropertyTypes errors by only including properties when values exist
 */
function buildDateFilter(
  entityType: 'appointment' | 'booking' | 'customer',
  startDate?: Date,
  endDate?: Date
): Record<string, { gte?: Date; lte?: Date }> {
  const filter: Record<string, { gte?: Date; lte?: Date }> = {};

  if (entityType === 'appointment') {
    if (startDate && endDate) {
      filter['startDate'] = { gte: startDate };
      filter['endDate'] = { lte: endDate };
    } else if (startDate) {
      filter['startDate'] = { gte: startDate };
    } else if (endDate) {
      filter['endDate'] = { lte: endDate };
    }
  } else if (entityType === 'booking') {
    if (startDate && endDate) {
      filter['date'] = { gte: startDate, lte: endDate };
    } else if (startDate) {
      filter['date'] = { gte: startDate };
    } else if (endDate) {
      filter['date'] = { lte: endDate };
    }
  } else if (entityType === 'customer') {
    if (startDate && endDate) {
      filter['createdAt'] = { gte: startDate, lte: endDate };
    } else if (startDate) {
      filter['createdAt'] = { gte: startDate };
    } else if (endDate) {
      filter['createdAt'] = { lte: endDate };
    }
  }

  return filter;
}

/**
 * Get the date range for the previous period
 */
function getPreviousRange(startDate: Date, endDate: Date): { startDate: Date; endDate: Date } {
  const diffMs = endDate.getTime() - startDate.getTime();

  return {
    startDate: new Date(startDate.getTime() - diffMs),
    endDate: new Date(startDate.getTime() - 1), // End just before the current period starts
  };
}

/**
 * Build type-safe createdAt filter for customer queries
 */
function buildCreatedAtFilter(startDate?: Date, endDate?: Date): Prisma.CustomerWhereInput {
  const where: Prisma.CustomerWhereInput = {};

  if (startDate || endDate) {
    const createdAt: Prisma.DateTimeFilter = {};

    if (startDate) {
      createdAt.gte = startDate;
    }

    if (endDate) {
      createdAt.lte = endDate;
    }

    where.createdAt = createdAt;
  }

  return where;
}

export const statsRouter = router({
  /**
   * Get all dashboard statistics and summary data
   */
  getStats: publicProcedure.input(StatsFilterSchema.optional()).query(async ({ input }) => {
    // Default to current month if no period specified
    const period = input?.period ?? 'month';
    const compareToPrevious = input?.compareWithPrevious ?? true;

    try {
      // Get date ranges for filtering
      const { startDate, endDate } = formatDateRange(period);
      let previousStartDate, previousEndDate;

      if (compareToPrevious) {
        const previousRange = getPreviousRange(startDate, endDate);
        previousStartDate = previousRange.startDate;
        previousEndDate = previousRange.endDate;
      }

      // Get appointments counts
      const [
        totalAppointments,
        upcomingAppointments,
        completedAppointments,
        appointmentsInPeriod,
        previousPeriodAppointments,
      ] = await Promise.all([
        prisma.appointment.count(),
        prisma.appointment.count({
          where: {
            startTime: { gte: new Date() },
            status: { in: [AppointmentStatus.PENDING, AppointmentStatus.CONFIRMED] },
          },
        }),
        prisma.appointment.count({
          where: {
            status: AppointmentStatus.COMPLETED,
          },
        }),
        prisma.appointment.count({
          where: buildDateFilter('appointment', startDate, endDate),
        }),
        compareToPrevious
          ? prisma.appointment.count({
              where: buildDateFilter('appointment', previousStartDate, previousEndDate),
            })
          : 0,
      ]);

      // Get customers counts
      const [totalCustomers, newCustomersInPeriod, previousPeriodNewCustomers] = await Promise.all([
        prisma.customer.count(),
        prisma.customer.count({
          where: buildCreatedAtFilter(startDate, endDate),
        }),
        compareToPrevious && previousStartDate && previousEndDate
          ? prisma.customer.count({
              where: {
                createdAt: {
                  gte: previousStartDate,
                  lte: previousEndDate,
                },
              },
            })
          : 0,
      ]);

      // Get revenue statistics from appointments instead of payments
      const [appointmentsWithRevenue] = await Promise.all([
        prisma.appointment.findMany({
          where: {
            ...buildDateFilter('appointment', startDate, endDate),
            status: AppointmentStatus.COMPLETED,
          },
          select: {
            id: true,
            startTime: true,
          },
        }),
        compareToPrevious && previousStartDate && previousEndDate
          ? prisma.appointment.findMany({
              where: {
                ...buildDateFilter('appointment', previousStartDate, previousEndDate),
                status: AppointmentStatus.COMPLETED,
              },
              select: {
                id: true,
                startTime: true,
              },
            })
          : [],
      ]);

      // Calculate revenue totals from completed appointments
      // We can now use the totalPrice field from the Appointment model
      const [totalRevenueFromAppointments, previousPeriodRevenueFromAppointments] = await Promise.all([
        prisma.appointment.aggregate({
          where: {
            ...buildDateFilter('appointment', startDate, endDate),
            status: AppointmentStatus.COMPLETED,
          },
          _sum: {
            totalPrice: true
          }
        }),
        compareToPrevious && previousStartDate && previousEndDate
          ? prisma.appointment.aggregate({
              where: {
                ...buildDateFilter('appointment', previousStartDate, previousEndDate),
                status: AppointmentStatus.COMPLETED,
              },
              _sum: {
                totalPrice: true
              }
            })
          : Promise.resolve({ _sum: { totalPrice: 0 } })
      ]);

      // Also check for revenue from Cal.com bookings
      const [calBookingsRevenue, previousPeriodCalBookingsRevenue] = await Promise.all([
        prisma.calBooking.aggregate({
          where: {
            startTime: { gte: startDate, lte: endDate },
            paymentStatus: 'COMPLETED',
          },
          _sum: {
            paymentAmount: true
          }
        }),
        compareToPrevious && previousStartDate && previousEndDate
          ? prisma.calBooking.aggregate({
              where: {
                startTime: { gte: previousStartDate, lte: previousEndDate },
                paymentStatus: 'COMPLETED',
              },
              _sum: {
                paymentAmount: true
              }
            })
          : Promise.resolve({ _sum: { paymentAmount: 0 } })
      ]);

      // Combine revenue from both sources
      const totalRevenue = (totalRevenueFromAppointments._sum.totalPrice ?? 0) + 
                           (calBookingsRevenue._sum.paymentAmount ?? 0);
      
      const previousPeriodRevenue = (previousPeriodRevenueFromAppointments._sum.totalPrice ?? 0) + 
                                    (previousPeriodCalBookingsRevenue._sum.paymentAmount ?? 0);

      // Calculate percentage changes
      const appointmentChange = compareToPrevious && previousPeriodAppointments > 0
        ? ((appointmentsInPeriod - previousPeriodAppointments) / previousPeriodAppointments) * 100
        : 0;

      const customerChange = compareToPrevious && previousPeriodNewCustomers > 0
        ? ((newCustomersInPeriod - previousPeriodNewCustomers) / previousPeriodNewCustomers) * 100
        : 0;

      const revenueChange = compareToPrevious && previousPeriodRevenue > 0
        ? ((totalRevenue - previousPeriodRevenue) / previousPeriodRevenue) * 100
        : 0;

      return {
        appointments: {
          total: totalAppointments,
          upcoming: upcomingAppointments,
          completed: completedAppointments,
          inPeriod: appointmentsInPeriod,
          change: appointmentChange,
        },
        customers: {
          total: totalCustomers,
          newInPeriod: newCustomersInPeriod,
          change: customerChange,
        },
        revenue: {
          total: totalRevenue,
          inPeriod: totalRevenue,
          change: revenueChange,
          paymentsCount: appointmentsWithRevenue.length,
        },
        period: {
          label: period,
          startDate: startDate.toISOString(),
          endDate: endDate.toISOString(),
        },
      };
    } catch (error) {
      return handleRouterError(error, {
        operation: 'query',
        procedureName: 'getStats',
        routerName: 'stats',
        input
      });
    }
  }),

  getWeeklyBookings: publicProcedure.query(async () => {
    try {
      // Get last 7 days of contact submissions (since bookings are handled by Cal.com)
      const endDate = new Date();
      const startDate = new Date();
      startDate.setDate(endDate.getDate() - 6); // Last 7 days including today

      const contacts = await prisma.contact.findMany({
        where: {
          createdAt: {
            gte: startDate,
            lte: endDate,
          },
        },
        select: {
          id: true,
          createdAt: true,
        },
        orderBy: {
          createdAt: 'asc',
        },
      });

      // Create chart data for last 7 days
      const chartData = [];
      
      for (let i = 0; i < 7; i++) {
        const date = new Date(startDate);
        date.setDate(startDate.getDate() + i);
        
        const dayContacts = contacts.filter(contact => {
          const contactDate = new Date(contact.createdAt);
          return contactDate.toDateString() === date.toDateString();
        });

        chartData.push({
          day: date.toLocaleDateString('en-US', { weekday: 'short' }),
          date: date.toISOString().split('T')[0],
          bookings: dayContacts.length, // Keep property name as 'bookings' for frontend compatibility
        });
      }

      return chartData;
    } catch (error) {
      return handleRouterError(error, {
        operation: 'query',
        procedureName: 'getWeeklyBookings',
        routerName: 'stats'
      });
    }
  }),

  getServiceDistribution: publicProcedure.query(async () => {
    try {
      // Get service distribution from appointments
      const appointments = await prisma.appointment.findMany({
        where: {
          status: { in: [AppointmentStatus.COMPLETED, AppointmentStatus.CONFIRMED, AppointmentStatus.PENDING] },
        },
        // No title or description fields in current schema
        select: {
          id: true,
          serviceId: true, // Use serviceId instead of title
        },
      });

      // Group appointments by service type (based on title)
      const serviceMap = new Map<string, number>();
      
      appointments.forEach(appointment => {
        const serviceName = appointment.serviceId ?? 'Other';
        serviceMap.set(serviceName, (serviceMap.get(serviceName) ?? 0) + 1);
      });

      // Convert to chart data format
      const chartData = Array.from(serviceMap.entries()).map(([name, value]) => ({
        name,
        value,
        percentage: Math.round((value / appointments.length) * 100),
      }));

      // Sort by value descending
      chartData.sort((a, b) => b.value - a.value);

      return chartData;
    } catch (error) {
      return handleRouterError(error, {
        operation: 'query',
        procedureName: 'getServiceDistribution',
        routerName: 'stats'
      });
    }
  }),
});/**
 * Dashboard Appointments tRPC Router
 *
 * Provides type-safe procedures for appointment management within the dashboard.
 * Split from dashboard-router.ts for better maintainability and organization.
 */

import { z } from 'zod';
import { logger } from '@/lib/logger';
import { router, publicProcedure } from '@/lib/trpc/procedures';
import { prisma } from '@/lib/db/prisma';
import { TRPCError } from '@trpc/server';
import { sanitizeForPrisma } from '@/lib/utils/prisma-helper';
import { Prisma } from '@prisma/client';
// Appointments filter schema using Zod
const AppointmentsFilterSchema = z.object({
  startDate: z.string().optional(),
  endDate: z.string().optional(),
  status: z.string().optional(),
  search: z.string().optional(),
  artistId: z.string().optional(),
  customerId: z.string().optional(),
  limit: z.number().min(1).max(100).default(50),
  cursor: z.string().optional(),
});

/**
 * Format appointment time for display
 */
function formatAppointmentTime(date: Date): string {
  return date.toLocaleString('en-US', {
    month: 'short',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    hour12: true,
  });
}

export const appointmentsRouter = router({
  getUpcomingAppointments: publicProcedure
    .input(AppointmentsFilterSchema)
    .query(async ({ input }) => {
      const { status, limit, page, startDate, endDate } = input;
      const skip = (page - 1) * limit;

      try {
        // Build the where clause using type-safe techniques
        const where: Prisma.AppointmentWhereInput = {};

        // Filter by status if not "all"
        if (status !== 'all') {
          where.status = status;
        }

        // Default to upcoming appointments if no date range provided
        if (!startDate && !endDate) {
          where.startTime = { gte: new Date() };
        } else {
          // Apply custom date range if provided
          const dateFilter: Prisma.DateTimeFilter = {};

          if (startDate) {
            dateFilter.gte = new Date(startDate);
          }

          if (endDate) {
            dateFilter.lte = new Date(endDate);
          }

          where.startTime = dateFilter;
        }

        // Get appointments with count for pagination
        const [appointments, totalCount] = await Promise.all([
          prisma.appointment.findMany({
            where,
            orderBy: {
              startTime: 'asc',
            },
            skip,
            take: limit,
            // Note: Customer relationship not available in current schema
            // Use userId to fetch customer info separately if needed
          }),
          prisma.appointment.count({ where }),
        ]);

        // Transform appointments for frontend consumption
        const transformedAppointments = appointments.map((appointment) => ({
          id: appointment.id,
          // Use field names that exist in the schema
          startDate: appointment.startTime.toISOString(),
          endDate: appointment.endTime.toISOString(),
          status: appointment.status,
          // Note: Customer not directly related in schema
          customer: null, // Would need separate fetch
          userId: appointment.userId,
          formattedTime: formatAppointmentTime(appointment.startTime),
          duration: Math.round((appointment.endTime.getTime() - appointment.startTime.getTime()) / (1000 * 60)), // Duration in minutes
          createdAt: appointment.createdAt.toISOString(),
          updatedAt: appointment.updatedAt.toISOString(),
        }));

        // Calculate pagination metadata
        const totalPages = Math.ceil(totalCount / limit);
        const hasNextPage = page < totalPages;
        const hasPrevPage = page > 1;

        return {
          appointments: transformedAppointments,
          pagination: {
            total: totalCount,
            page,
            limit,
            totalPages,
            hasNextPage,
            hasPrevPage,
          },
        };
      } catch (error) {
        void logger.error('Error fetching upcoming appointments:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch upcoming appointments',
          cause: error,
        });
      }
    }),

  confirmAppointment: publicProcedure
    .input(z.string())
    .mutation(async ({ input: appointmentId }) => {
      try {
        // Get the appointment first to validate it exists
        const appointment = await prisma.appointment.findUnique({
          where: { id: appointmentId },
        });

        if (!appointment) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Appointment not found',
          });
        }

        // Update the appointment status
        const updatedAppointment = await prisma.appointment.update({
          where: { id: appointmentId },
          data: sanitizeForPrisma({
            status: 'CONFIRMED',
            updatedAt: new Date(),
          }),
        });

        return {
          success: true,
          appointment: updatedAppointment,
        };
      } catch (error) {
        void logger.error('Error confirming appointment:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to confirm appointment',
          cause: error,
        });
      }
    }),

  cancelAppointment: publicProcedure
    .input(z.object({
      id: z.string(),
      reason: z.string().optional(),
    }))
    .mutation(async ({ input }) => {
      try {
        // Get the appointment first to validate it exists
        const appointment = await prisma.appointment.findUnique({
          where: { id: input.id },
        });

        if (!appointment) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Appointment not found',
          });
        }

        // Update the appointment status to cancelled
        const updatedAppointment = await prisma.appointment.update({
          where: { id: input.id },
          data: sanitizeForPrisma({
            status: 'cancelled',
            notes: input.reason ? `Cancelled: ${input.reason}` : 'Cancelled',
            updatedAt: new Date(),
          }),
        });

        return {
          success: true,
          appointment: updatedAppointment,
        };
      } catch (error) {
        void logger.error('Error cancelling appointment:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to cancel appointment',
          cause: error,
        });
      }
    }),

  rescheduleAppointment: publicProcedure
    .input(z.object({
      id: z.string(),
      startDate: z.string().transform(str => new Date(str)),
      endDate: z.string().transform(str => new Date(str)),
    }))
    .mutation(async ({ input }) => {
      try {
        // Get the appointment first to validate it exists
        const appointment = await prisma.appointment.findUnique({
          where: { id: input.id },
        });

        if (!appointment) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Appointment not found',
          });
        }

        // Validate that the new time slot is available
        const conflictingAppointment = await prisma.appointment.findFirst({
          where: {
            id: { not: input.id },
            startTime: { lt: input.endDate },
            endTime: { gt: input.startDate },
            status: { in: ['SCHEDULED', 'CONFIRMED'] },
          },
        });

        if (conflictingAppointment) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: 'Time slot is already booked',
          });
        }

        // Update the appointment with new times
        const updatedAppointment = await prisma.appointment.update({
          where: { id: input.id },
          data: sanitizeForPrisma({
            startTime: input.startDate,
            endTime: input.endDate,
            status: 'CONFIRMED', // Reset to confirmed after rescheduling
            updatedAt: new Date(),
          }),
        });

        return {
          success: true,
          appointment: updatedAppointment,
        };
      } catch (error) {
        void logger.error('Error rescheduling appointment:', error);
        if (error instanceof TRPCError) {
          throw error;
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to reschedule appointment',
          cause: error,
        });
      }
    }),
});/**
 * Dashboard Contacts tRPC Router
 *
 * Provides type-safe procedures for contact management within the dashboard.
 * Split from dashboard-router.ts for better maintainability and organization.
 */

import { z } from 'zod';
import { logger } from '@/lib/logger';
import { router, publicProcedure } from '@/lib/trpc/procedures';
import { prisma } from '@/lib/db/prisma';
import { TRPCError } from '@trpc/server';
// Recent contacts schema using Zod
const RecentContactsSchema = z.object({
  limit: z.number().min(1).max(100).default(10),
  cursor: z.string().optional(),
  search: z.string().optional(),
  orderBy: z.enum(['newest', 'oldest', 'name']).default('newest'),
});

export const contactsRouter = router({
  getRecentContacts: publicProcedure.input(RecentContactsSchema).query(async ({ input }) => {
    const { limit } = input;

    try {
      const contacts = await prisma.contact.findMany({
        take: limit,
        orderBy: {
          createdAt: 'desc',
        },
        select: {
          id: true,
          name: true,
          email: true,
          subject: true,
          message: true,
          createdAt: true,
        },
      });

      // Transform contacts for frontend consumption
      const transformedContacts = contacts.map((contact) => ({
        id: contact.id,
        name: contact.name,
        email: contact.email,
        subject: contact.subject ?? 'No Subject',
        message: contact.message.length > 100 
          ? `${contact.message.substring(0, 100)}...` 
          : contact.message,
        fullMessage: contact.message,
        read: false, // Default to unread since Contact model doesn't have read field
        createdAt: contact.createdAt.toISOString(),
        timeAgo: getTimeAgo(contact.createdAt),
      }));

      return {
        contacts: transformedContacts,
        unreadCount: contacts.length, // All contacts considered unread since no read field
      };
    } catch (error) {
      void logger.error('Error fetching recent contacts:', error);
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Failed to fetch recent contacts',
        cause: error,
      });
    }
  }),

  // Note: markContactAsRead removed since Contact model doesn't have read field
  // If read status is needed, add read field to Contact model in Prisma schema

  deleteContact: publicProcedure
    .input(z.object({ id: z.string() })) // Contact id is string based on schema
    .mutation(async ({ input }) => {
      try {
        await prisma.contact.delete({
          where: { id: input.id },
        });

        return {
          success: true,
        };
      } catch (error) {
        void logger.error('Error deleting contact:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to delete contact',
          cause: error,
        });
      }
    }),
});

/**
 * Helper function to get human-readable time ago string
 */
function getTimeAgo(date: Date): string {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / (1000 * 60));
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);

  if (diffMins < 1) {
    return 'Just now';
  } else if (diffMins < 60) {
    return `${diffMins} minute${diffMins === 1 ? '' : 's'} ago`;
  } else if (diffHours < 24) {
    return `${diffHours} hour${diffHours === 1 ? '' : 's'} ago`;
  } else if (diffDays < 7) {
    return `${diffDays} day${diffDays === 1 ? '' : 's'} ago`;
  } else {
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: date.getFullYear() !== now.getFullYear() ? 'numeric' : undefined,
    });
  }
}/**
 * Cal.com Analytics tRPC Router
 * 
 * Purpose: Type-safe API endpoints for Cal.com analytics and dashboard data
 * Assumptions: Database available, analytics service configured
 * Dependencies: tRPC, Prisma, Cal.com analytics service, Zod validation
 * 
 * Trade-offs:
 * - Type safety vs development speed: Complete type coverage vs rapid iteration
 * - Comprehensive validation vs performance: Data integrity vs query speed
 * - Caching vs real-time data: Performance vs data freshness
 */

import { z } from 'zod';
import { logger } from '@/lib/logger';
import { TRPCError } from '@trpc/server';
import { router, adminProcedure, publicProcedure } from '@/lib/trpc/procedures';
import { calAnalyticsService } from '@/lib/analytics/cal-analytics-service';
import { calApi } from '@/lib/cal/api';
import { prisma as db } from '@/lib/db';
import { Prisma } from '@prisma/client';

// Sync result type
interface SyncResult {
  processed: number;
  updated: number;
  created: number;
  errors: number;
}

// Input Schemas
const dateRangeSchema = z.object({
  startDate: z.date(),
  endDate: z.date(),
}).refine(
  (data) => data.startDate < data.endDate,
  { message: "Start date must be before end date" }
);

const syncOptionsSchema = z.object({
  forceFullSync: z.boolean().default(false),
  batchSize: z.number().min(1).max(1000).default(100),
  syncType: z.enum(['bookings', 'event_types', 'all']).default('bookings'),
});

const paginationSchema = z.object({
  limit: z.number().min(1).max(100).default(10),
  offset: z.number().min(0).default(0),
});

const bookingFiltersSchema = z.object({
  status: z.enum(['PENDING', 'ACCEPTED', 'CONFIRMED', 'CANCELLED', 'REJECTED', 'COMPLETED']).optional(),
  eventTypeId: z.number().optional(),
  attendeeEmail: z.string().email().optional(),
  dateRange: dateRangeSchema.optional(),
});

// Cal.com Analytics Router
export const calAnalyticsRouter = router({
  // Dashboard Metrics
  getDashboardMetrics: adminProcedure
    .input(dateRangeSchema)
    .query(async ({ input }) => {
      try {
        const metrics = await calAnalyticsService.getDashboardMetrics(input);
        
        return {
          success: true,
          data: metrics,
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error fetching dashboard metrics:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch dashboard metrics',
          cause: error,
        });
      }
    }),

  // Real-time Metrics
  getTodayMetrics: adminProcedure
    .query(async () => {
      try {
        const today = new Date();
        const startOfDay = new Date(today.getFullYear(), today.getMonth(), today.getDate());
        
        const [todayBookings, todayRevenue, liveMetrics] = await Promise.all([
          db.calBooking.count({
            where: { createdAt: { gte: startOfDay } },
          }),
          db.calBooking.aggregate({
            where: {
              createdAt: { gte: startOfDay },
              paymentStatus: 'COMPLETED',
            },
            _sum: { paymentAmount: true },
          }),
          // Get live metrics from cache or calculate
          db.calMetricsSnapshot.findFirst({
            where: {
              date: startOfDay,
              hour: new Date().getHours(),
            },
            orderBy: { createdAt: 'desc' },
          }),
        ]);

        return {
          success: true,
          data: {
            todayBookings,
            todayRevenue: todayRevenue._sum.paymentAmount ?? 0,
            liveVisitors: liveMetrics?.liveVisitors ?? 0,
            activeSessions: liveMetrics?.activeSessions ?? 0,
            conversionRate: liveMetrics?.conversionRate ?? 0,
          },
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error fetching today metrics:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch today metrics',
          cause: error,
        });
      }
    }),

  // Booking Management
  getBookings: adminProcedure
    .input(bookingFiltersSchema.merge(paginationSchema))
    .query(async ({ input }) => {
      try {
        const { limit, offset, status, eventTypeId, attendeeEmail, dateRange } = input;
        
        const where: Prisma.CalBookingWhereInput = {};
        
        if (status) where.status = status;
        if (eventTypeId) where.eventTypeId = eventTypeId;
        if (attendeeEmail) where.attendeeEmail = attendeeEmail;
        if (dateRange) {
          where.startTime = {
            gte: dateRange.startDate,
            lte: dateRange.endDate,
          };
        }

        const [bookings, total] = await Promise.all([
          db.calBooking.findMany({
            where,
            orderBy: { createdAt: 'desc' },
            take: limit,
            skip: offset,
            select: {
              id: true,
              calBookingUid: true,
              title: true,
              attendeeName: true,
              attendeeEmail: true,
              startTime: true,
              endTime: true,
              status: true,
              serviceName: true,
              paymentAmount: true,
              paymentStatus: true,
              createdAt: true,
            },
          }),
          db.calBooking.count({ where }),
        ]);

        return {
          success: true,
          data: {
            bookings,
            pagination: {
              total,
              hasMore: offset + limit < total,
              nextOffset: offset + limit < total ? offset + limit : null,
            },
          },
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error fetching bookings:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch bookings',
          cause: error,
        });
      }
    }),

  // Get specific booking details
  getBookingById: adminProcedure
    .input(z.object({ id: z.string() }))
    .query(async ({ input }) => {
      try {
        const booking = await db.calBooking.findUnique({
          where: { id: input.id },
          include: {
            customer: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true,
                phone: true,
                totalSpent: true,
                bookingCount: true,
              },
            },
          },
        });

        if (!booking) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Booking not found',
          });
        }

        // Get related bookings for this customer
        const relatedBookings = await db.calBooking.findMany({
          where: {
            attendeeEmail: booking.attendeeEmail,
            id: { not: booking.id },
          },
          orderBy: { createdAt: 'desc' },
          take: 5,
          select: {
            id: true,
            title: true,
            startTime: true,
            status: true,
            paymentAmount: true,
          },
        });

        return {
          success: true,
          data: {
            booking,
            relatedBookings,
          },
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        
        void logger.error('Error fetching booking:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch booking details',
          cause: error,
        });
      }
    }),

  // Data Synchronization
  syncCalData: adminProcedure
    .input(syncOptionsSchema)
    .mutation(async ({ input }) => {
      try {
        const { forceFullSync, batchSize, syncType } = input;
        
        const results: Record<string, SyncResult> = {};

        if (syncType === 'bookings' || syncType === 'all') {
          const bookingResults = await calAnalyticsService.syncCalBookings({
            forceFullSync,
            batchSize,
            maxRetries: 3,
          });
          results['bookings'] = bookingResults;
        }

        if (syncType === 'event_types' || syncType === 'all') {
          // Sync event types
          const eventTypes = await calApi.getEventTypes();
          
          const eventTypeResults = { processed: 0, updated: 0, created: 0, errors: 0 };
          
          for (const eventType of eventTypes.data) {
            try {
              await db.calEventType.upsert({
                where: { calEventTypeId: eventType.id },
                update: {
                  title: eventType.title,
                  slug: eventType.slug,
                  description: eventType.description ?? null,
                  length: eventType.length,
                  price: eventType.price,
                  currency: eventType.currency,
                  hidden: eventType.hidden,
                  requiresConfirmation: eventType.requiresConfirmation,
                  syncedAt: new Date(),
                },
                create: {
                  calEventTypeId: eventType.id,
                  title: eventType.title,
                  slug: eventType.slug,
                  description: eventType.description ?? null,
                  length: eventType.length,
                  price: eventType.price,
                  currency: eventType.currency,
                  hidden: eventType.hidden,
                  requiresConfirmation: eventType.requiresConfirmation,
                  syncedAt: new Date(),
                },
              });
              
              eventTypeResults.processed++;
            } catch (error) {
              void logger.error(`Error syncing event type ${eventType.id}:`, error);
              eventTypeResults.errors++;
            }
          }
          
          results['eventTypes'] = eventTypeResults;
        }

        return {
          success: true,
          data: results,
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error syncing Cal.com data:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to sync Cal.com data',
          cause: error,
        });
      }
    }),

  // Service Performance Analytics
  getServicePerformance: adminProcedure
    .input(dateRangeSchema.optional())
    .query(async ({ input }) => {
      try {
        const dateRange = input ?? {
          startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
          endDate: new Date(),
        };

        const serviceStats = await db.calBooking.groupBy({
          by: ['eventTypeId', 'serviceName'],
          where: {
            createdAt: {
              gte: dateRange.startDate,
              lte: dateRange.endDate,
            },
          },
          _count: { eventTypeId: true },
          _sum: { paymentAmount: true },
          _avg: { paymentAmount: true },
          orderBy: { _count: { eventTypeId: 'desc' } },
        });

        const enrichedStats = await Promise.all(
          serviceStats.map(async (stat: typeof serviceStats[number]) => {
            // Get conversion rate (confirmed vs total bookings)
            const [totalBookings, confirmedBookings] = await Promise.all([
              db.calBooking.count({
                where: {
                  eventTypeId: stat.eventTypeId,
                  createdAt: {
                    gte: dateRange.startDate,
                    lte: dateRange.endDate,
                  },
                },
              }),
              db.calBooking.count({
                where: {
                  eventTypeId: stat.eventTypeId,
                  status: { in: ['ACCEPTED', 'CONFIRMED'] },
                  createdAt: {
                    gte: dateRange.startDate,
                    lte: dateRange.endDate,
                  },
                },
              }),
            ]);

            const conversionRate = totalBookings > 0 ? (confirmedBookings / totalBookings) * 100 : 0;

            return {
              eventTypeId: stat.eventTypeId,
              serviceName: stat.serviceName,
              totalBookings: stat._count.eventTypeId,
              totalRevenue: stat._sum.paymentAmount ?? 0,
              averageValue: stat._avg.paymentAmount ?? 0,
              conversionRate,
              confirmedBookings,
            };
          })
        );

        return {
          success: true,
          data: enrichedStats,
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error fetching service performance:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch service performance data',
          cause: error,
        });
      }
    }),

  // Customer Analytics
  getCustomerAnalytics: adminProcedure
    .input(dateRangeSchema.optional())
    .query(async ({ input }) => {
      try {
        const dateRange = input ?? {
          startDate: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
          endDate: new Date(),
        };

        const [
          totalCustomers,
          newCustomers,
          returningCustomers,
          topCustomers,
          customerGrowth,
        ] = await Promise.all([
          db.customer.count(),
          db.customer.count({
            where: {
              createdAt: {
                gte: dateRange.startDate,
                lte: dateRange.endDate,
              },
            },
          }),
          db.customer.count({
            where: {
              bookingCount: { gt: 1 },
              lastBookingAt: {
                gte: dateRange.startDate,
                lte: dateRange.endDate,
              },
            },
          }),
          db.customer.findMany({
            orderBy: { totalSpent: 'desc' },
            take: 10,
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              totalSpent: true,
              bookingCount: true,
              lastBookingAt: true,
            },
          }),
          // Get daily customer growth
          db.$queryRaw<Array<{ date: string; newCustomers: bigint }>>(`
            SELECT 
              DATE(created_at) as date,
              COUNT(*) as "newCustomers"
            FROM customer 
            WHERE created_at >= ${dateRange.startDate} 
              AND created_at <= ${dateRange.endDate}
            GROUP BY DATE(created_at)
            ORDER BY date ASC
          `),
        ]);

        return {
          success: true,
          data: {
            overview: {
              totalCustomers,
              newCustomers,
              returningCustomers,
              retentionRate: totalCustomers > 0 ? (returningCustomers / totalCustomers) * 100 : 0,
            },
            topCustomers,
            growth: customerGrowth.map((day: { date: string; newCustomers: bigint }) => ({
              date: day.date,
              newCustomers: Number(day.newCustomers),
            })),
          },
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error fetching customer analytics:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch customer analytics',
          cause: error,
        });
      }
    }),

  // Health Status
  getHealthStatus: adminProcedure
    .query(async () => {
      try {
        const health = await calAnalyticsService.getServiceHealth();
        
        return {
          success: true,
          data: health,
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error checking health status:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to check service health',
          cause: error,
        });
      }
    }),

  // Webhook Events
  getWebhookEvents: adminProcedure
    .input(paginationSchema.merge(z.object({
      processed: z.boolean().optional(),
      triggerEvent: z.string().optional(),
    })))
    .query(async ({ input }) => {
      try {
        const { limit, offset, processed, triggerEvent } = input;
        
        const where: Prisma.CalWebhookEventWhereInput = {};
        if (processed !== undefined) where.processed = processed;
        if (triggerEvent) where.triggerEvent = triggerEvent;

        const [events, total] = await Promise.all([
          db.calWebhookEvent.findMany({
            where,
            orderBy: { receivedAt: 'desc' },
            take: limit,
            skip: offset,
            select: {
              id: true,
              triggerEvent: true,
              calBookingId: true,
              calBookingUid: true,
              processed: true,
              processingError: true,
              retryCount: true,
              receivedAt: true,
              processedAt: true,
            },
          }),
          db.calWebhookEvent.count({ where }),
        ]);

        return {
          success: true,
          data: {
            events,
            pagination: {
              total,
              hasMore: offset + limit < total,
              nextOffset: offset + limit < total ? offset + limit : null,
            },
          },
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error fetching webhook events:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch webhook events',
          cause: error,
        });
      }
    }),

  // Public endpoint for basic metrics (for homepage, etc.)
  getPublicMetrics: publicProcedure
    .query(async () => {
      try {
        const [totalBookings, totalCustomers, totalRevenue] = await Promise.all([
          db.calBooking.count({
            where: { status: { in: ['ACCEPTED', 'CONFIRMED', 'COMPLETED'] } },
          }),
          db.customer.count(),
          db.calBooking.aggregate({
            where: { paymentStatus: 'COMPLETED' },
            _sum: { paymentAmount: true },
          }),
        ]);

        return {
          success: true,
          data: {
            totalBookings,
            totalCustomers,
            totalRevenue: totalRevenue._sum.paymentAmount ?? 0,
            // Don't expose sensitive data in public endpoint
          },
          timestamp: new Date().toISOString(),
        };
      } catch (error) {
        void logger.error('Error fetching public metrics:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch public metrics',
          cause: error,
        });
      }
    }),
});/**
 * Admin Router
 *
 * This router handles all admin-related API endpoints,
 * including dashboard data and user management.
 */
import { z } from 'zod';
import { adminProcedure, router } from '../procedures';
import { TRPCError } from '@trpc/server';
import { Prisma, NoteType } from '@prisma/client';
import { randomUUID } from 'node:crypto';
import { logger } from '@/lib/logger';
import { prisma } from '../../db/prisma';
import {
  GetNotesByCustomerSchema,
  CreateNoteSchema,
  UpdateNoteSchema,
  DeleteNoteSchema,
  PinNoteSchema,
} from '@/lib/schemas/note-schemas';

// Export the admin router with all procedures
export const adminRouter = router({
  getDashboardStats: adminProcedure.query(async () => {
    const usersCount = await prisma.user.count();
    const customersCount = await prisma.customer.count();
    const bookingsCount = 0; // TODO: update to fetch data from cal.com integration and/or api routes
    const appointmentsCount = 0; // TODO: update to fetch data from cal.com integration and/or api routes
    const artistsCount = 0; // TODO: update to fetch data from cal.com integration and/or api routes
    const testimonialsCount = 0; // TODO: update when testimonial model is added to schema
    const designsCount = await prisma.tattooDesign.count();

    // Return all stats
    return {
      counts: {
        users: usersCount,
        customers: customersCount,
        bookings: bookingsCount,
        appointments: appointmentsCount,
        artists: artistsCount,
        testimonials: testimonialsCount,
        designs: designsCount,
      },
    };
  }),

  // Customer endpoints
  customers: router({
    getAll: adminProcedure
      .input(
        z.object({
          limit: z.number().min(1).max(1000).default(100),
          cursor: z.string().nullish(),
          search: z.string().optional(),
        })
      )
      .query(async ({ input }) => {
        const { limit, cursor, search } = input;

        // Build the where clause
        let where: Prisma.CustomerWhereInput = {};

        // Add search filter if provided
        if (search) {
          where = {
            OR: [
              { firstName: { contains: search, mode: 'insensitive' } },
              { lastName: { contains: search, mode: 'insensitive' } },
              { email: { contains: search, mode: 'insensitive' } },
              { phone: { contains: search, mode: 'insensitive' } },
            ],
          };
        }

        const customers = await prisma.customer.findMany({
          where,
          take: limit + 1,
          ...(cursor ? { cursor: { id: cursor } } : {}),
          orderBy: { createdAt: 'desc' },
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            phone: true,
            createdAt: true,
            updatedAt: true,
          },
        });

        let nextCursor: string | undefined;
        if (customers.length > limit) {
          const nextItem = customers.pop();
          nextCursor = nextItem?.id;
        }

        return {
          items: customers,
          nextCursor,
        };
      }),
  }),

  // Get customer list with pagination
  getCustomers: adminProcedure
    .input(
      z.object({
        page: z.number().min(1).default(1),
        limit: z.number().min(1).max(100).default(20),
        search: z.string().optional(),
      })
    )
    .query(async ({ input }) => {
      const { page, limit, search } = input;
      const skip = (page - 1) * limit;

      // Build the where clause
      let where: Prisma.CustomerWhereInput = {};

      // Add search filter if provided
      if (search) {
        where = {
          OR: [
            { firstName: { contains: search, mode: 'insensitive' } },
            { lastName: { contains: search, mode: 'insensitive' } },
            { email: { contains: search, mode: 'insensitive' } },
            { phone: { contains: search, mode: 'insensitive' } },
          ],
        };
      }

      // Get total count for pagination
      const totalCount = await prisma.customer.count({ where });

      // Get customers
      const customers = await prisma.customer.findMany({
        where,
        skip,
        take: limit,
        orderBy: { createdAt: 'desc' },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
          address: true,
          city: true,
          state: true,
          postalCode: true,
          notes: true,
          tags: true,
          createdAt: true,
          updatedAt: true,
        },
      });

      // Calculate total pages
      const totalPages = Math.ceil(totalCount / limit);

      return {
        customers,
        pagination: {
          page,
          limit,
          totalCount,
          totalPages,
        },
      };
    }),

  // Get customers with infinite scroll pagination
  getCustomersInfinite: adminProcedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).default(20),
        cursor: z.number().nullish(),
        search: z.string().optional(),
      })
    )
    .query(async ({ input }) => {
      const { limit, cursor, search } = input;

      // Build the where clause
      let where: Prisma.CustomerWhereInput = {};

      // Add search filter if provided
      if (search) {
        where = {
          OR: [
            { firstName: { contains: search, mode: 'insensitive' } },
            { lastName: { contains: search, mode: 'insensitive' } },
            { email: { contains: search, mode: 'insensitive' } },
            { phone: { contains: search, mode: 'insensitive' } },
          ],
        };
      }

      // Get total count for reference
      const totalCount = await prisma.customer.count({ where });

      // Get customers with cursor pagination
      // Using Prisma type for proper type checking
      const findManyOptions: Prisma.CustomerFindManyArgs = {
        where,
        take: limit + 1, // Take one extra to check if there's more
        orderBy: { createdAt: 'desc' },
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true,
          phone: true,
          createdAt: true,
          updatedAt: true,
          tags: true,
        },
      };

      if (cursor) {
        findManyOptions.cursor = { id: cursor.toString() };
      }

      const customers = await prisma.customer.findMany(findManyOptions);

      let nextCursor: number | null = null;
      if (customers.length > limit) {
        const nextItem = customers.pop();
        nextCursor = nextItem ? parseInt(nextItem.id) : null;
      }

      return {
        customers,
        nextCursor,
        totalCount,
      };
    }),

  // Get customer details by ID
  getCustomerById: adminProcedure.input(z.object({ id: z.string() })).query(async ({ input }) => {
    const customer = await prisma.customer.findUnique({
      where: { id: input.id },
      // Select only fields that exist in the schema
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true,
        phone: true,
        address: true,
        city: true,
        state: true,
        postalCode: true,
        notes: true,
        tags: true,
        createdAt: true,
        updatedAt: true,
      },
    });

    if (!customer) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: `Customer with ID ${input.id} not found`,
      });
    }

    return customer;
  }),

  // Update customer details
  updateCustomer: adminProcedure
    .input(
      z.object({
        id: z.string(),
        firstName: z.string().min(1).optional(),
        lastName: z.string().min(1).optional(),
        email: z.string().email().optional(),
        phone: z.string().optional(),
        address: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        postalCode: z.string().optional(),
        country: z.string().optional(),
        birthDate: z.date().optional(),
        source: z.string().optional(),
        personalNotes: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      const { id } = input;

      try {
        // Convert the input data to a format acceptable by Prisma
        const updateData: Prisma.CustomerUpdateInput = {};

        if (input.firstName !== null && input.firstName !== undefined)
          updateData.firstName = input.firstName;
        if (input.lastName !== null && input.lastName !== undefined)
          updateData.lastName = input.lastName;
        if (input.email !== null && input.email !== undefined) updateData.email = input.email;
        if (input.phone !== null && input.phone !== undefined) updateData.phone = input.phone;
        if (input.address !== null && input.address !== undefined)
          updateData.address = input.address;
        if (input.city !== null && input.city !== undefined) updateData.city = input.city;
        if (input.state !== null && input.state !== undefined) updateData.state = input.state;
        if (input.postalCode !== null && input.postalCode !== undefined)
          updateData.postalCode = input.postalCode;
        if (input.country !== null && input.country !== undefined)
          updateData.country = input.country;
        if (input.birthDate !== null && input.birthDate !== undefined)
          updateData.birthDate = input.birthDate;

        const updatedCustomer = await prisma.customer.update({
          where: { id },
          data: updateData,
        });

        return updatedCustomer;
      } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to update customer: ${error.message}`,
            cause: error,
          });
        }
        throw error;
      }
    }),

  // Get all notes for a customer
  getCustomerNotes: adminProcedure
    .input(GetNotesByCustomerSchema)
    .query(async ({ input }) => {
      try {
        const { customerId, limit, cursor, type, pinnedOnly } = input;
        
        // Build where clause based on input
        const where: Prisma.NoteWhereInput = { 
          customerId 
        };
        
        // Add type filter if not 'all'
        if (type !== 'all') {
          where.type = type as NoteType;
        }
        
        // Add pinned filter if requested
        if (pinnedOnly) {
          where.pinned = true;
        }
        
        // Get notes with pagination
        const notes = await prisma.note.findMany({
          where,
          take: limit + 1, // Take one extra to check if there are more
          ...(cursor ? { cursor: { id: cursor } } : {}),
          orderBy: [
            { pinned: 'desc' },  // Pinned notes first
            { createdAt: 'desc' } // Then by creation date (newest first)
          ],
          include: {
            customer: {
              select: {
                id: true,
                firstName: true,
                lastName: true,
                email: true
              }
            }
          }
        });
        
        // Check if there are more notes and set next cursor
        let nextCursor: string | undefined = undefined;
        if (notes.length > limit) {
          const nextItem = notes.pop(); // Remove the extra item
          nextCursor = nextItem?.id;
        }
        
        return {
          notes,
          nextCursor,
        };
      } catch (error) {
        void logger.error('Error fetching customer notes', { error, customerId: input.customerId });
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch customer notes',
          cause: error,
        });
      }
    }),

  // Add a note to a customer
  addCustomerNote: adminProcedure
    .input(CreateNoteSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        const { customerId, content, type, pinned } = input;
        const userId = ctx.userId ?? null;
        
        // Verify the customer exists
        const customer = await prisma.customer.findUnique({
          where: { id: customerId },
          select: { id: true },
        });
        
        if (!customer) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Customer with ID ${customerId} not found`,
          });
        }
        
        // Create a new note in the database
        const newNote = await prisma.note.create({
          data: {
            id: randomUUID(),
            content,
            type: type as NoteType,
            pinned: pinned ?? false,
            customerId,
            createdBy: userId,
            createdAt: new Date(),
            updatedAt: new Date(),
          },
        });
        
        return newNote;
      } catch (error) {
        void logger.error('Error adding customer note', { error, customerId: input.customerId });
        if (error instanceof TRPCError) {
          throw error;
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to add customer note',
          cause: error,
        });
      }
    }),

  // Update a customer note
  updateCustomerNote: adminProcedure
    .input(UpdateNoteSchema)
    .mutation(async ({ input }) => {
      try {
        const { id, content, pinned, type } = input;
        
        // Verify the note exists
        const existingNote = await prisma.note.findUnique({
          where: { id },
        });
        
        if (!existingNote) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Note with ID ${id} not found`,
          });
        }
        
        // Prepare update data
        const updateData: Prisma.NoteUpdateInput = {};
        
        if (content !== undefined) updateData.content = content;
        if (pinned !== undefined) updateData.pinned = pinned;
        if (type !== undefined) updateData.type = type as NoteType;
        updateData.updatedAt = new Date();
        
        // Update the note
        const updatedNote = await prisma.note.update({
          where: { id },
          data: updateData,
        });
        
        return updatedNote;
      } catch (error) {
        void logger.error('Error updating customer note', { error, noteId: input.id });
        if (error instanceof TRPCError) {
          throw error;
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to update customer note',
          cause: error,
        });
      }
    }),

  // Delete a customer note
  deleteCustomerNote: adminProcedure
    .input(DeleteNoteSchema)
    .mutation(async ({ input }) => {
      try {
        const { id } = input;
        
        // Verify the note exists
        const existingNote = await prisma.note.findUnique({
          where: { id },
        });
        
        if (!existingNote) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Note with ID ${id} not found`,
          });
        }
        
        // Delete the note
        await prisma.note.delete({
          where: { id },
        });
        
        return { success: true };
      } catch (error) {
        void logger.error('Error deleting customer note', { error, noteId: input.id });
        if (error instanceof TRPCError) {
          throw error;
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to delete customer note',
          cause: error,
        });
      }
    }),

  // Pin or unpin a note
  pinNote: adminProcedure
    .input(PinNoteSchema)
    .mutation(async ({ input }) => {
      try {
        const { id, pinned } = input;
        
        // Verify the note exists
        const existingNote = await prisma.note.findUnique({
          where: { id },
        });
        
        if (!existingNote) {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: `Note with ID ${id} not found`,
          });
        }
        
        // Update the pinned status
        const updatedNote = await prisma.note.update({
          where: { id },
          data: {
            pinned,
            updatedAt: new Date(),
          },
        });
        
        return updatedNote;
      } catch (error) {
        void logger.error('Error pinning/unpinning note', { error, noteId: input.id, pinStatus: input.pinned });
        if (error instanceof TRPCError) {
          throw error;
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to update note pinned status',
          cause: error,
        });
      }
    }),

  // Manage customer tags
  addTagToCustomer: adminProcedure
    .input(
      z.object({
        customerId: z.string(),
        tagId: z.string(),
      })
    )
    .mutation(async ({ input }) => {
      try {
        // Use a direct query approach to avoid Prisma type issues
        await prisma.$queryRaw`
          INSERT INTO "_CustomerToTag" ("A", "B")
          VALUES (${input.customerId}, ${input.tagId})
          ON CONFLICT DO NOTHING;
        `;
        const updatedCustomer = await prisma.customer.findUnique({
          where: { id: input.customerId },
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            tags: true
          }
        });

        return updatedCustomer;
      } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to add tag: ${error.message}`,
            cause: error,
          });
        }
        throw error;
      }
    }),

  // Remove tag from customer
  removeTagFromCustomer: adminProcedure
    .input(
      z.object({
        customerId: z.string(),
        tagId: z.string(),
      })
    )
    .mutation(async ({ input }) => {
      try {
        // Use raw query to avoid schema mismatches
  await prisma.$queryRaw`DELETE FROM "_CustomerToTag"
          WHERE "A" = ${input.customerId} AND "B" = ${input.tagId};
        `;
        const customer = await prisma.customer.findUnique({
          where: { id: input.customerId },
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            tags: true
          },
        });

        return customer;
      } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to remove tag: ${error.message}`,
            cause: error,
          });
        }
        throw error;
      }
    }),

  // Get all tags - Remove tag operations since Tag model doesn't exist
  getTags: adminProcedure.query(async () => {
    // Return empty array since Tag model doesn't exist in schema
    logger.warn('Tag model not found in schema - returning empty array');
    return [];
  }),

  // Create a new tag - Disabled since Tag model doesn't exist
  createTag: adminProcedure
    .input(
      z.object({
        name: z.string().min(1),
        color: z.string().default('gray'),
      })
    )
    .mutation(async () => {
      throw new TRPCError({
        code: 'NOT_IMPLEMENTED',
        message: 'Tag functionality not implemented - Tag model not found in schema',
      });
    }),

  // Delete a tag - Disabled since Tag model doesn't exist
  deleteTag: adminProcedure.input(z.object({ id: z.string() })).mutation(async () => {
    throw new TRPCError({
      code: 'NOT_IMPLEMENTED',
      message: 'Tag functionality not implemented - Tag model not found in schema',
    });
  }),

  // Create a new customer
  createCustomer: adminProcedure
    .input(
      z.object({
        firstName: z.string().min(1, 'First name is required'),
        lastName: z.string().min(1, 'Last name is required'),
        email: z.string().email('Valid email is required'),
        phone: z.string().optional(),
        address: z.string().optional(),
        city: z.string().optional(),
        state: z.string().optional(),
        zipCode: z.string().optional(),
      })
    )
    .mutation(async ({ input }) => {
      try {
        const customerId = randomUUID();        
        const customer = await prisma.customer.create({
          data: {
            id: customerId,
            firstName: input.firstName.trim(),
            lastName: input.lastName.trim(),
            email: input.email.trim().toLowerCase(),
            phone: input.phone?.trim() ?? null,
            address: input.address?.trim() ?? null,
            city: input.city?.trim() ?? null,
            state: input.state?.trim() ?? null,
            postalCode: input.zipCode?.trim() ?? null,
            communicationPrefs: 'EMAIL', // Add required field
            updatedAt: new Date(),
            createdAt: new Date()
          },
          // Only select the fields we need to avoid serialization issues
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true,
            phone: true,
            address: true,
            city: true,
            state: true,
            postalCode: true,
            createdAt: true,
            updatedAt: true,
          },
        });

        return customer;
      } catch (error) {
        if (error instanceof Prisma.PrismaClientKnownRequestError) {
          // Handle unique constraint violation (email already exists)
          if (error.code === 'P2002') {
            throw new TRPCError({
              code: 'BAD_REQUEST',
              message: 'A customer with this email already exists',
              cause: error,
            });
          }

          throw new TRPCError({
            code: 'INTERNAL_SERVER_ERROR',
            message: `Failed to create customer: ${error.message}`,
            cause: error,
          });
        }
        throw error;
      }
    }),
});
/**
 * Modern Dashboard tRPC Router
 *
 * Provides type-safe procedures for all dashboard-related data fetching and actions.
 * Modularized for better maintainability using domain-specific sub-routers.
 * 
 * This replaces the original 1012-line dashboard-router.ts with a cleaner,
 * React 19 compatible structure split across multiple focused routers.
 */

import { router } from '@/lib/trpc/procedures';
import { statsRouter } from './dashboard/stats-router';
import { contactsRouter } from './dashboard/contacts-router';
import { activityRouter } from './dashboard/activity-router';

/**
 * Main dashboard router that combines all domain-specific routers
 * 
 * Structure:
 * - stats: Dashboard statistics and overview data
 * - contacts: Contact management and communication  
 * - activity: Activity tracking and notifications
 * 
 * Note: Bookings, appointments, and payments are handled via Cal.com integration
 * and are managed through the respective dedicated routers (cal-router, etc.)
 */
export const dashboardRouter = router({
  // Statistics and overview data
  stats: statsRouter,
  
  // Contact management
  contacts: contactsRouter,
  
  // Activity tracking and notifications
  activity: activityRouter,
});/**
 * Cal.com tRPC Router
 *
 * This router handles all Cal.com related operations through tRPC.
 */

import { z } from 'zod';
import { logger } from '@/lib/logger';
import { adminProcedure, protectedProcedure, publicProcedure, router } from '../procedures';
import {
  getCalBookings,
  getCalBookingByUid,
  getCalEventTypes,
  updateCalBookingStatus,
  rescheduleCalBooking,
  getCalAvailability,
} from '@/lib/cal/api';
import type { CalBooking, CalEventType } from '@prisma/client';
import type { CalBookingWithRelations } from '@/lib/prisma-types';
import { TRPCError } from '@trpc/server';
import { isCalConfigured } from '@/lib/cal/config';
import { prisma } from '@/lib/db/prisma';
import { ENV, SERVER_ENV } from '@/lib/utils/env';

export const calRouter = router({
  // Get Cal.com configuration status
  getConfigStatus: publicProcedure.query(async () => {
    const configured = isCalConfigured();
    return {
      configured,
      calUsername: ENV.NEXT_PUBLIC_CAL_USERNAME ?? null,
      hasApiKey: Boolean(SERVER_ENV.CAL_API_KEY),
      hasWebhookSecret: Boolean(SERVER_ENV.CAL_WEBHOOK_SECRET),
    };
  }),

  // Get all bookings from Cal.com
  getBookings: adminProcedure
    .input(
      z
        .object({
          limit: z.number().optional(),
          status: z.string().optional(),
          eventTypeId: z.number().optional(),
        })
        .optional()
    )
    .query(async ({ input }) => {
      try {
        const options: GetCalBookingsOptions = {};
        if (input?.limit !== undefined) options.limit = input.limit;
        if (input?.status !== undefined) options.status = input.status;
        if (input?.eventTypeId !== undefined) options.eventTypeId = input.eventTypeId;
        return await getCalBookings(options);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to get Cal.com bookings: ${errorMessage}`,
        });
      }
    }),

  // Get a specific booking by UID
  getBookingByUid: adminProcedure.input(z.object({ uid: z.string() })).query(async ({ input }) => {
    try {
      return await getCalBookingByUid(input.uid);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: `Failed to get Cal.com booking: ${errorMessage}`,
      });
    }
  }),

  // Get all event types from Cal.com
  getEventTypes: adminProcedure.query(async () => {
    try {
      return await getCalEventTypes();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: `Failed to get Cal.com event types: ${errorMessage}`,
      });
    }
  }),

  // Update a booking status
  updateBookingStatus: adminProcedure
    .input(
      z.object({
        uid: z.string(),
        status: z.enum(['accepted', 'rejected', 'cancelled']),
      })
    )
    .mutation(async ({ input }) => {
      try {
        return await updateCalBookingStatus(input.uid, input.status);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to update Cal.com booking status: ${errorMessage}`,
        });
      }
    }),

  // Reschedule a booking
  rescheduleBooking: adminProcedure
    .input(
      z.object({
        uid: z.string(),
        newTime: z.object({
          start: z.string(),
          end: z.string(),
        }),
      })
    )
    .mutation(async ({ input }) => {
      try {
        return await rescheduleCalBooking(input.uid, input.newTime);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to reschedule Cal.com booking: ${errorMessage}`,
        });
      }
    }),

  // Get availability slots for an event type
  getAvailability: protectedProcedure
    .input(
      z.object({
        eventTypeId: z.number(),
        startDate: z.string(),
        endDate: z.string(),
      })
    )
    .query(async ({ input }) => {
      try {
        return await getCalAvailability(input.eventTypeId, input.startDate, input.endDate);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to get Cal.com availability: ${errorMessage}`,
        });
      }
    }),

  // Sync Cal.com bookings with internal database
  syncBookings: adminProcedure.mutation(async () => {
    try {
      // Get all bookings from Cal.com
      const calBookings = await getCalBookings({});

      // Track statistics for the sync operation
      const stats = {
        total: calBookings.length,
        created: 0,
        updated: 0,
        unchanged: 0,
        failed: 0,
      };

      // Process each booking
      for (const booking of calBookings) {
        try {
          // Check if booking already exists in our database
          const existingBooking = await prisma.booking.findFirst({
            where: {
              calBookingUid: booking.uid,
            },
          });

          if (existingBooking) {
            // Update existing booking
            await prisma.booking.update({
              where: {
                id: existingBooking.id,
              },
              data: {
                calStatus: booking.status,
                updatedAt: new Date(),
              },
            });
            stats.updated++;
          } else {
            // Create new booking record
            if (booking.attendees.length > 0) {
              // Extract attendee information safely
              const attendeeName =
                booking.attendees && booking.attendees.length > 0
                  ? (booking.attendees[0]?.['name'] ?? 'Unknown')
                  : 'Unknown';
              const attendeeEmail =
                booking.attendees && booking.attendees.length > 0
                  ? (booking.attendees[0]?.['email'] ?? 'unknown@example.com')
                  : 'unknown@example.com';

              // Extract customInputs if they exist
              interface CustomInput {
                label: string;
                value: string;
              }

              const customInputs = Array.isArray(booking['customInputs'])
                ? (booking['customInputs'] as CustomInput[])
                : [];
              const getTattooTypeInput = customInputs.find((i) => i['label'] === 'Tattoo Type');
              const getSizeInput = customInputs.find((i) => i['label'] === 'Size');
              const getPlacementInput = customInputs.find((i) => i['label'] === 'Placement');

              // Create the booking record
              await prisma.booking.create({
                data: {
                  name: attendeeName,
                  email: attendeeEmail,
                  phone: 'Not provided',
                  calBookingUid: booking.uid,
                  calEventTypeId: booking.eventType ? booking.eventType.id : null,
                  calStatus: booking.status,
                  calMeetingUrl: booking.meetingUrl ?? null,

                  tattooType: getTattooTypeInput?.value ?? 'Not specified',
                  size: getSizeInput?.value ?? 'Not specified',
                  placement: getPlacementInput?.value ?? 'Not specified',
                  description: booking.description ?? 'Cal.com booking',
                  preferredDate: new Date(booking.startTime),
                  preferredTime: new Date(booking.startTime).toLocaleTimeString(),
                  paymentMethod: 'None',
                  source: 'cal.com',
                },
              });
              stats.created++;
            }
          }
        } catch (error) {
          void logger.error(`Failed to sync booking ${booking.uid}:`, error);
          stats.failed++;
        }
      }

      return {
        success: true,
        stats,
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: `Failed to sync Cal.com bookings: ${errorMessage}`,
      });
    }
  }),

  // Get dashboard metrics combining Cal.com and website data
  getDashboardMetrics: adminProcedure
    .input(
      z.object({
        startDate: z.string(),
        endDate: z.string(),
      })
    )
    .query(async ({ input }) => {
      try {
        const startDate = new Date(input.startDate);
        const endDate = new Date(input.endDate);
        
        // Get Cal.com bookings for the period
        const calBookings = await getCalBookings({});
        const periodBookings = calBookings.filter(booking => {
          const bookingDate = new Date(booking.startTime);
          return bookingDate >= startDate && bookingDate <= endDate;
        });
        
        // Get database bookings for comparison
        const dbBookings = await prisma.booking.findMany({
          where: {
            createdAt: {
              gte: startDate,
              lte: endDate,
            },
          },
        });
        
        // Calculate metrics
        const totalBookings = Math.max(periodBookings.length, dbBookings.length);
        const confirmedBookings = periodBookings.filter(b => b.status === 'accepted').length;
        const cancelledBookings = periodBookings.filter(b => b.status === 'cancelled').length;
        
        // Estimate revenue (simplified calculation)
        const totalRevenue = confirmedBookings * 150; // Average tattoo price
        
        // Get customer count from database
        const customerCount = await prisma.customer.count();
        
        // Calculate trends (simplified)
        const conversionRate = totalBookings > 0 ? (confirmedBookings / totalBookings) * 100 : 0;
        
        return {
          totalBookings,
          confirmedBookings,
          cancelledBookings,
          totalRevenue,
          customerCount,
          conversionRate,
          // Add trend indicators
          bookingsTrend: totalBookings > 0 ? 5 : 0,
          revenueTrend: totalRevenue > 0 ? 8 : 0,
          conversionTrend: conversionRate > 80 ? 3 : -2,
          customersTrend: customerCount > 10 ? 12 : 5,
        };
      } catch (error) {
        void logger.error('Error fetching dashboard metrics:', error);
        // Return default values if Cal.com API fails
        const dbBookings = await prisma.booking.count({
          where: {
            createdAt: {
              gte: new Date(input.startDate),
              lte: new Date(input.endDate),
            },
          },
        });
        
        const customerCount = await prisma.customer.count();
        
        return {
          totalBookings: dbBookings,
          confirmedBookings: Math.floor(dbBookings * 0.8),
          cancelledBookings: Math.floor(dbBookings * 0.1),
          totalRevenue: dbBookings * 150,
          customerCount,
          conversionRate: 80,
          bookingsTrend: 5,
          revenueTrend: 8,
          conversionTrend: 3,
          customersTrend: 12,
        };
      }
    }),

  // Get recent bookings combining Cal.com and database data
  getRecentBookings: adminProcedure
    .input(
      z.object({
        limit: z.number().default(10),
      })
    )
    .query(async ({ input }) => {
      try {
        // Get recent Cal.com bookings
        const calBookings = await getCalBookings({ limit: input.limit });
        
        // Transform Cal.com bookings to match expected format
        const recentBookings = calBookings.slice(0, input.limit).map(booking => ({
          id: booking.uid,
          uid: booking.uid,
          title: booking.title ?? `${booking.eventType?.title ?? 'Appointment'}`,
          status: booking.status,
          startTime: booking.startTime,
          endTime: booking.endTime,
          attendeeEmail: booking.attendees?.[0]?.email ?? 'Unknown',
          attendeeName: booking.attendees?.[0]?.name ?? 'Unknown',
          eventType: booking.eventType?.slug ?? 'appointment',
          calEventTypeId: booking.eventType?.id ?? null,
          source: 'cal.com',
          createdAt: booking.createdAt ?? booking.startTime,
        }));
        
        return recentBookings;
      } catch (error) {
        void logger.error('Error fetching recent bookings:', error);
        // Fallback to database bookings if Cal.com fails
        const dbBookings = await prisma.booking.findMany({
          take: input.limit,
          orderBy: { createdAt: 'desc' },
        });
        
        return dbBookings.map(booking => ({
          id: booking.id,
          uid: booking.calBookingUid ?? booking.id,
          title: `${booking.tattooType} - ${booking.name}`,
          status: booking.calStatus ?? 'pending',
          startTime: booking.preferredDate.toISOString(),
          endTime: booking.preferredDate.toISOString(),
          attendeeEmail: booking.email,
          attendeeName: booking.name,
          eventType: booking.tattooType,
          calEventTypeId: booking.calEventTypeId,
          source: booking.source ?? 'website',
          createdAt: booking.createdAt.toISOString(),
        }));
      }
    }),

  // Enhanced booking creation for intercepted booking flow
  createEnhancedBooking: protectedProcedure
    .input(
      z.object({
        appointmentType: z.enum(['consultation', 'design-review', 'tattoo-session']),
        scheduledTime: z.string().optional(),
        duration: z.number().optional(),
        customerInfo: z.object({
          name: z.string(),
          email: z.string().email(),
          phone: z.string().optional(),
          timeZone: z.string().optional(),
        }).optional(),
        designType: z.enum(['traditional', 'japanese', 'realism', 'custom', 'cover-up']).optional(),
        estimatedSize: z.enum(['small', 'medium', 'large', 'sleeve']).optional(),
        bodyPlacement: z.string().optional(),
        colorPreference: z.enum(['black-gray', 'color', 'mixed', 'unsure']).optional(),
        previousTattoos: z.boolean().optional(),
        allergies: z.string().optional(),
        referenceImages: z.array(z.string()).optional(),
        notes: z.string().optional(),
        paymentInfo: z.object({
          amount: z.number(),
          currency: z.string(),
          status: z.string(),
          paymentMethod: z.string().optional(),
        }).optional(),
        tattooSpecific: z.object({
          designType: z.string(),
          estimatedSize: z.string().optional(),
          bodyPlacement: z.string().optional(),
          colorPreference: z.string().optional(),
          previousTattoos: z.boolean(),
          allergies: z.string().optional(),
          referenceImages: z.array(z.string()),
        }).optional(),
        calBookingId: z.string().optional(),
        calBookingUid: z.string().optional(),
        calEventTypeId: z.number().optional(),
      })
    )
    .mutation(async ({ input }) => {
      try {
        // Create clean object with required fields
        const bookingData: {
          name: string;
          email: string;
          phone: string;
          tattooType: string;
          size: string;
          placement: string;
          description: string;
          preferredDate: Date;
          preferredTime: string;
          paymentMethod: string;
          source: string;
          calBookingUid?: string;
          calEventTypeId?: number;
          calStatus: string;
          notes: string;
        } = {
          name: input.customerInfo?.name ?? 'Unknown Customer',
          email: input.customerInfo?.email ?? 'unknown@example.com',
          phone: input.customerInfo?.phone ?? '',
          tattooType: input.tattooSpecific?.designType ?? input.designType ?? 'consultation',
          size: input.tattooSpecific?.estimatedSize ?? input.estimatedSize ?? 'medium',
          placement: input.tattooSpecific?.bodyPlacement ?? input.bodyPlacement ?? 'TBD',
          description: input.notes ?? `${input.appointmentType} appointment`,
          preferredDate: input.scheduledTime ? new Date(input.scheduledTime) : new Date(),
          preferredTime: input.scheduledTime ? new Date(input.scheduledTime).toLocaleTimeString() : 'TBD',
          paymentMethod: input.paymentInfo?.paymentMethod ?? 'unspecified',
          source: 'modern_cal_integration',
          calStatus: 'pending',
          notes: ''  // Will be set below
        };
        
        // Only add optional properties if they're defined
        if (input.calBookingUid !== undefined) {
          bookingData.calBookingUid = input.calBookingUid;
        }
        
        if (input.calEventTypeId !== undefined) {
          bookingData.calEventTypeId = input.calEventTypeId;
        }
        
        // Build tattooSpecific notes object with type safety
        const notesObj: {
          appointmentType: string;
          tattooSpecific?: Record<string, unknown>;
          colorPreference?: string;
          previousTattoos?: boolean;
          allergies?: string;
          referenceImages: string[];
        } = {
          appointmentType: input.appointmentType,
          referenceImages: input.referenceImages ?? []
        };
        
        // Add optional properties to notes object only if they're defined
        if (input.colorPreference !== undefined) {
          notesObj.colorPreference = input.colorPreference;
        }
        
        if (input.previousTattoos !== undefined) {
          notesObj.previousTattoos = input.previousTattoos;
        }
        
        if (input.allergies !== undefined) {
          notesObj.allergies = input.allergies;
        }
        
        // Add tattooSpecific object if it exists
        if (input.tattooSpecific) {
          const tattooSpecificObj: Record<string, unknown> = {
            designType: input.tattooSpecific.designType,
            previousTattoos: input.tattooSpecific.previousTattoos,
            referenceImages: input.tattooSpecific.referenceImages
          };
          
          if (input.tattooSpecific['estimatedSize'] !== undefined) {
            tattooSpecificObj['estimatedSize'] = input.tattooSpecific['estimatedSize'];
          }
          
          if (input.tattooSpecific['bodyPlacement'] !== undefined) {
            tattooSpecificObj['bodyPlacement'] = input.tattooSpecific['bodyPlacement'];
          }
          
          if (input.tattooSpecific['colorPreference'] !== undefined) {
            tattooSpecificObj['colorPreference'] = input.tattooSpecific['colorPreference'];
          }
          
          if (input.tattooSpecific['allergies'] !== undefined) {
            tattooSpecificObj['allergies'] = input.tattooSpecific['allergies'];
          }
          
          notesObj.tattooSpecific = tattooSpecificObj;
        }
        
        // Convert notes object to JSON string
        bookingData.notes = JSON.stringify(notesObj);
        
        // Create booking with clean data
        const booking = await prisma.booking.create({
          data: bookingData
        });

        // Create a clean TattooBookingData object
        const enhancedBookingData: TattooBookingData = {
          appointmentType: input.appointmentType,
        };
        
        // Add optional fields only if they're defined
        if (input.scheduledTime !== undefined) {
          enhancedBookingData.scheduledTime = input.scheduledTime;
        }
        
        if (input.duration !== undefined) {
          enhancedBookingData.duration = input.duration;
        }
        
        // Handle nested customerInfo object
        if (input.customerInfo) {
          enhancedBookingData.customerInfo = {
            name: input.customerInfo.name,
            email: input.customerInfo.email,
            timeZone: input.customerInfo.timeZone ?? 'UTC'
          };
          
          if (input.customerInfo.phone !== undefined) {
            enhancedBookingData.customerInfo.phone = input.customerInfo.phone;
          }
        }
        
        // Add all other optional fields
        if (input.designType !== undefined) {
          enhancedBookingData.designType = input.designType;
        }
        
        if (input.estimatedSize !== undefined) {
          enhancedBookingData.estimatedSize = input.estimatedSize;
        }
        
        if (input.bodyPlacement !== undefined) {
          enhancedBookingData.bodyPlacement = input.bodyPlacement;
        }
        
        if (input.colorPreference !== undefined) {
          enhancedBookingData.colorPreference = input.colorPreference;
        }
        
        if (input.previousTattoos !== undefined) {
          enhancedBookingData.previousTattoos = input.previousTattoos;
        }
        
        if (input.allergies !== undefined) {
          enhancedBookingData.allergies = input.allergies;
        }
        
        if (input.referenceImages !== undefined) {
          enhancedBookingData.referenceImages = input.referenceImages;
        }
        
        if (input.notes !== undefined) {
          enhancedBookingData.notes = input.notes;
        }
        
        // Handle nested paymentInfo object
        if (input.paymentInfo) {
          enhancedBookingData.paymentInfo = {
            amount: input.paymentInfo.amount,
            currency: input.paymentInfo.currency,
            status: input.paymentInfo.status,
          };
          
          if (input.paymentInfo.paymentMethod !== undefined) {
            enhancedBookingData.paymentInfo.paymentMethod = input.paymentInfo.paymentMethod;
          }
        }
        
        // Handle nested tattooSpecific object
        if (input.tattooSpecific) {
          enhancedBookingData.tattooSpecific = {
            designType: input.tattooSpecific.designType,
            previousTattoos: input.tattooSpecific.previousTattoos,
            referenceImages: input.tattooSpecific.referenceImages
          };
          
          if (input.tattooSpecific.estimatedSize !== undefined) {
            enhancedBookingData.tattooSpecific.estimatedSize = input.tattooSpecific.estimatedSize;
          }
          
          if (input.tattooSpecific.bodyPlacement !== undefined) {
            enhancedBookingData.tattooSpecific.bodyPlacement = input.tattooSpecific.bodyPlacement;
          }
          
          if (input.tattooSpecific.colorPreference !== undefined) {
            enhancedBookingData.tattooSpecific.colorPreference = input.tattooSpecific.colorPreference;
          }
          
          if (input.tattooSpecific.allergies !== undefined) {
            enhancedBookingData.tattooSpecific.allergies = input.tattooSpecific.allergies;
          }
        }
        
        // Add Cal.com specific fields from the booking
        if (booking.calBookingUid) {
          enhancedBookingData.calBookingUid = booking.calBookingUid;
        }
        
        if (booking.calEventTypeId) {
          enhancedBookingData.calEventTypeId = booking.calEventTypeId;
        }

        return enhancedBookingData;
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: `Failed to create enhanced booking: ${errorMessage}`,
        });
      }
    }),
});
/**
 * Settings Router - Refactored Version
 * 
 * This is a refactored version of the settings router that uses proper database persistence
 * via the SettingsService, providing better type safety, error handling, and maintainability.
 */

import { z } from 'zod';
import { router, protectedProcedure, adminProcedure } from '@/lib/trpc/procedures';
import { TRPCError } from '@trpc/server';
import { revalidatePath } from 'next/cache';
import { sendEmail } from '@/lib/email/email-service';
import { logger } from '@/lib/logger';
import { settingsService } from '@/lib/services/settings-service';
// Settings form types - simplified inline definitions
// Use Prisma-derived settings type instead of manual definition
type GeneralSettingsForm = {
  siteName: string;
  siteDescription: string;
  contactEmail: string;
  contactPhone: string;
  address: string;
  businessHours: string;
  timezone: string;
  logoUrl?: string | null;
  faviconUrl?: string | null;
  googleAnalyticsId?: string | null;
  facebookPixelId?: string | null;
  primaryColor?: string;
  secondaryColor?: string;
};

type BookingSettingsForm = {
  bookingEnabled: boolean;
  requireDeposit: boolean;
  depositAmount: number;
  maxAdvanceBookingDays: number;
  minAdvanceBookingHours: number;
  cancellationHours: number;
  autoConfirmBookings: boolean;
  sendReminderEmails: boolean;
  reminderHoursBefore: number;
  slotDuration: number;
  bufferTimeBetweenAppointments: number;
  workingDays: number[];
  workingHoursStart: string;
  workingHoursEnd: string;
};

type EmailSettingsForm = {
  emailProvider: 'resend' | 'sendgrid' | 'smtp';
  fromName: string;
  fromEmail: string;
  replyToEmail: string;
  sendWelcomeEmails: boolean;
  sendBookingConfirmations: boolean;
  sendPaymentConfirmations: boolean;
  sendCancellationNotices: boolean;
  emailTemplateStyle: 'modern' | 'classic' | 'minimal';
  emailFooterText?: string | null;
  emailLogoUrl?: string | null;
  smtpHost?: string | null;
  smtpPort?: number | null;
  smtpUser?: string | null;
  smtpPassword?: string | null;
  smtpSecure?: boolean | null;
};

type SecuritySettingsForm = {
  requireTwoFactor: boolean;
  sessionTimeout: number;
  maxLoginAttempts: number;
  lockoutDuration: number;
  requireStrongPasswords: boolean;
  passwordMinLength: number;
  passwordRequireUppercase: boolean;
  passwordRequireNumbers: boolean;
  passwordRequireSymbols: boolean;
  allowApiAccess: boolean;
  logSecurityEvents: boolean;
  ipRateLimit: number;
  ipRateLimitWindowMinutes: number;
};

type NotificationSettingsForm = {
  newBookingAlerts: boolean;
  paymentAlerts: boolean;
  cancellationAlerts: boolean;
  systemMaintenanceAlerts: boolean;
  errorAlerts: boolean;
  weeklyReports: boolean;
  monthlyReports: boolean;
  notificationEmail?: string | null;
  smsNotifications: boolean;
  notificationPhone?: string | null;
  slackWebhook?: string | null;
  notificationChannels: string[];
  discordWebhook?: string | null;
  pushNotifications: boolean;
};

// Validation schemas (same as before)
const generalSettingsSchema = z.object({
  siteName: z.string().min(1, 'Site name cannot be empty').max(100, 'Site name is too long'),
  siteDescription: z.string().max(500, 'Site description is too long'),
  contactEmail: z.string().email('Please enter a valid email address'),
  contactPhone: z.string().regex(/^\+?[0-9\-() ]{7,20}$/, 'Please enter a valid phone number').optional().or(z.literal('')),
  address: z.string().max(300, 'Address is too long'),
  businessHours: z.string().max(500, 'Business hours text is too long'),
  timezone: z.string().regex(/^[A-Za-z_/+-]+$/, 'Invalid timezone format'),
  logoUrl: z.string().url('Logo must be a valid URL').optional().nullable(),
  faviconUrl: z.string().url('Favicon must be a valid URL').optional().nullable(),
  primaryColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Invalid hex color').optional(),
  secondaryColor: z.string().regex(/^#[0-9A-Fa-f]{6}$/, 'Invalid hex color').optional(),
  googleAnalyticsId: z.string().optional().nullable(),
  facebookPixelId: z.string().optional().nullable(),
}).strict();

const bookingSettingsSchema = z.object({
  bookingEnabled: z.boolean(),
  requireDeposit: z.boolean(),
  depositAmount: z.number().min(0, 'Deposit amount cannot be negative').max(10000, 'Deposit amount is too high'),
  maxAdvanceBookingDays: z.number().int().min(1, 'Must be at least 1 day').max(365, 'Cannot exceed 365 days'),
  minAdvanceBookingHours: z.number().int().min(1, 'Must be at least 1 hour').max(168, 'Cannot exceed 168 hours (1 week)'),
  cancellationHours: z.number().int().min(1, 'Must be at least 1 hour').max(168, 'Cannot exceed 168 hours (1 week)'),
  autoConfirmBookings: z.boolean(),
  sendReminderEmails: z.boolean(),
  reminderHoursBefore: z.number().int().min(1, 'Must be at least 1 hour').max(168, 'Cannot exceed 168 hours (1 week)'),
  slotDuration: z.number().int().min(15, 'Minimum slot is 15 minutes').max(240, 'Maximum slot is 240 minutes (4 hours)').default(60),
  bufferTimeBetweenAppointments: z.number().int().min(0, 'Cannot be negative').max(120, 'Cannot exceed 120 minutes (2 hours)').default(30),
  workingDays: z.array(z.number().int().min(0).max(6)).default([1, 2, 3, 4, 5]),
  workingHoursStart: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Invalid time format, use HH:MM').default('09:00'),
  workingHoursEnd: z.string().regex(/^([01]?[0-9]|2[0-3]):[0-5][0-9]$/, 'Invalid time format, use HH:MM').default('17:00'),
}).strict();

const emailSettingsSchema = z.object({
  emailProvider: z.enum(['resend', 'sendgrid', 'smtp']),
  fromName: z.string().min(1, 'From name cannot be empty').max(100, 'From name is too long'),
  fromEmail: z.string().email('Please enter a valid from email address'),
  replyToEmail: z.string().email('Please enter a valid reply-to email address'),
  sendWelcomeEmails: z.boolean(),
  sendBookingConfirmations: z.boolean(),
  sendPaymentConfirmations: z.boolean(),
  sendCancellationNotices: z.boolean(),
  emailTemplateStyle: z.enum(['modern', 'classic', 'minimal']).default('modern'),
  emailFooterText: z.string().max(500, 'Footer text is too long').optional().nullable(),
  emailLogoUrl: z.string().url('Logo must be a valid URL').optional().nullable(),
  smtpHost: z.string().optional().nullable(),
  smtpPort: z.number().int().min(1).max(65535).optional().nullable(),
  smtpUser: z.string().optional().nullable(),
  smtpPassword: z.string().optional().nullable(),
  smtpSecure: z.boolean().optional().nullable(),
}).strict();

const securitySettingsSchema = z.object({
  requireTwoFactor: z.boolean(),
  sessionTimeout: z.number().int().min(1, 'Session timeout must be at least 1 hour').max(720, 'Session timeout cannot exceed 720 hours (30 days)'),
  maxLoginAttempts: z.number().int().min(1, 'Must allow at least 1 attempt').max(20, 'Cannot exceed 20 attempts'),
  lockoutDuration: z.number().int().min(1, 'Lockout must be at least 1 minute').max(1440, 'Lockout cannot exceed 1440 minutes (24 hours)'),
  requireStrongPasswords: z.boolean(),
  passwordMinLength: z.number().int().min(8, 'Password must be at least 8 characters').max(128, 'Password cannot exceed 128 characters').default(12),
  passwordRequireUppercase: z.boolean().default(true),
  passwordRequireNumbers: z.boolean().default(true),
  passwordRequireSymbols: z.boolean().default(true),
  allowApiAccess: z.boolean(),
  logSecurityEvents: z.boolean(),
  ipRateLimit: z.number().int().min(10, 'Rate limit must be at least 10 requests').max(1000, 'Rate limit cannot exceed 1000 requests').default(100),
  ipRateLimitWindowMinutes: z.number().int().min(1, 'Rate limit window must be at least 1 minute').max(1440, 'Rate limit window cannot exceed 1440 minutes (24 hours)').default(15),
}).strict();

const notificationSettingsSchema = z.object({
  newBookingAlerts: z.boolean(),
  paymentAlerts: z.boolean(),
  cancellationAlerts: z.boolean(),
  systemMaintenanceAlerts: z.boolean(),
  errorAlerts: z.boolean(),
  weeklyReports: z.boolean(),
  monthlyReports: z.boolean(),
  notificationEmail: z.string().email('Please enter a valid notification email').optional().nullable(),
  smsNotifications: z.boolean().default(false),
  notificationPhone: z.string().optional().nullable(),
  slackWebhook: z.string().url('Slack webhook must be a valid URL').optional().nullable(),
  discordWebhook: z.string().url('Discord webhook must be a valid URL').optional().nullable(),
  pushNotifications: z.boolean().default(false),
}).strict();

const testEmailSchema = z.object({
  email: z.string().email('Please enter a valid email address'),
  template: z.enum(['basic', 'booking', 'payment', 'welcome']).default('basic')
}).strict();

// Type transformation functions to ensure compatibility with exact optional property types
function transformToGeneralSettings(data: z.infer<typeof generalSettingsSchema>): GeneralSettingsForm {
  const result: GeneralSettingsForm = {
    siteName: data.siteName,
    siteDescription: data.siteDescription,
    contactEmail: data.contactEmail,
    contactPhone: data.contactPhone ?? '',
    address: data.address,
    businessHours: data.businessHours,
    timezone: data.timezone,
    logoUrl: data.logoUrl ?? null,
    faviconUrl: data.faviconUrl ?? null,
    googleAnalyticsId: data.googleAnalyticsId ?? null,
    facebookPixelId: data.facebookPixelId ?? null,
  };
  
  // Only add optional properties if they have values
  if (data.primaryColor !== undefined) {
    result.primaryColor = data.primaryColor;
  }
  if (data.secondaryColor !== undefined) {
    result.secondaryColor = data.secondaryColor;
  }
  
  return result;
}

function transformToBookingSettings(data: z.infer<typeof bookingSettingsSchema>): BookingSettingsForm {
  return {
    bookingEnabled: data.bookingEnabled,
    requireDeposit: data.requireDeposit,
    depositAmount: data.depositAmount,
    maxAdvanceBookingDays: data.maxAdvanceBookingDays,
    minAdvanceBookingHours: data.minAdvanceBookingHours,
    cancellationHours: data.cancellationHours,
    autoConfirmBookings: data.autoConfirmBookings,
    sendReminderEmails: data.sendReminderEmails,
    reminderHoursBefore: data.reminderHoursBefore,
    slotDuration: data.slotDuration,
    bufferTimeBetweenAppointments: data.bufferTimeBetweenAppointments,
    workingDays: data.workingDays,
    workingHoursStart: data.workingHoursStart,
    workingHoursEnd: data.workingHoursEnd,
  };
}

function transformToEmailSettings(data: z.infer<typeof emailSettingsSchema>): EmailSettingsForm {
  return {
    emailProvider: data.emailProvider,
    fromName: data.fromName,
    fromEmail: data.fromEmail,
    replyToEmail: data.replyToEmail,
    sendWelcomeEmails: data.sendWelcomeEmails,
    sendBookingConfirmations: data.sendBookingConfirmations,
    sendPaymentConfirmations: data.sendPaymentConfirmations,
    sendCancellationNotices: data.sendCancellationNotices,
    emailTemplateStyle: data.emailTemplateStyle,
    emailFooterText: data.emailFooterText ?? null,
    emailLogoUrl: data.emailLogoUrl ?? null,
    smtpHost: data.smtpHost ?? null,
    smtpPort: data.smtpPort ?? null,
    smtpUser: data.smtpUser ?? null,
    smtpPassword: data.smtpPassword ?? null,
    smtpSecure: data.smtpSecure ?? null,
  };
}

function transformToSecuritySettings(data: z.infer<typeof securitySettingsSchema>): SecuritySettingsForm {
  return {
    requireTwoFactor: data.requireTwoFactor,
    sessionTimeout: data.sessionTimeout,
    maxLoginAttempts: data.maxLoginAttempts,
    lockoutDuration: data.lockoutDuration,
    requireStrongPasswords: data.requireStrongPasswords,
    passwordMinLength: data.passwordMinLength,
    passwordRequireUppercase: data.passwordRequireUppercase,
    passwordRequireNumbers: data.passwordRequireNumbers,
    passwordRequireSymbols: data.passwordRequireSymbols,
    allowApiAccess: data.allowApiAccess,
    logSecurityEvents: data.logSecurityEvents,
    ipRateLimit: data.ipRateLimit,
    ipRateLimitWindowMinutes: data.ipRateLimitWindowMinutes,
  };
}

function transformToNotificationSettings(data: z.infer<typeof notificationSettingsSchema>): NotificationSettingsForm {
  return {
    newBookingAlerts: data.newBookingAlerts,
    paymentAlerts: data.paymentAlerts,
    cancellationAlerts: data.cancellationAlerts,
    systemMaintenanceAlerts: data.systemMaintenanceAlerts,
    errorAlerts: data.errorAlerts,
    weeklyReports: data.weeklyReports,
    monthlyReports: data.monthlyReports,
    notificationEmail: data.notificationEmail ?? null,
    smsNotifications: data.smsNotifications,
    notificationPhone: data.notificationPhone ?? null,
    slackWebhook: data.slackWebhook ?? null,
    discordWebhook: data.discordWebhook ?? null,
    pushNotifications: data.pushNotifications,
    notificationChannels: [],
  };
}

/**
 * Enhanced Settings Router using SettingsService
 */
export const settingsRouter = router({
  // Get all settings
  getSettings: protectedProcedure.query(async () => {
    try {
      return await settingsService.getSettings();
    } catch (error) {
      logger.error('Error fetching settings:', error);
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Failed to fetch settings',
        cause: error,
      });
    }
  }),

  // Generic update settings endpoint with proper validation
  updateSettings: adminProcedure
    .input(z.object({
      domain: z.enum(['general', 'booking', 'email', 'security', 'notifications']),
      data: z.record(z.unknown())
    }))
    .mutation(async ({ input, ctx }) => {
      try {
        if (!ctx.userId) {
          throw new TRPCError({
            code: 'UNAUTHORIZED',
            message: 'User ID is required for this operation',
          });
        }

        const { domain, data } = input;

        // Validate based on domain
        let validatedData;
        switch (domain) {
          case 'general':
            validatedData = transformToGeneralSettings(generalSettingsSchema.parse(data));
            break;
          case 'booking':
            validatedData = transformToBookingSettings(bookingSettingsSchema.parse(data));
            break;
          case 'email':
            validatedData = transformToEmailSettings(emailSettingsSchema.parse(data));
            break;
          case 'security':
            validatedData = transformToSecuritySettings(securitySettingsSchema.parse(data));
            break;
          case 'notifications':
            validatedData = transformToNotificationSettings(notificationSettingsSchema.parse(data));
            break;
          default:
            throw new Error(`Unknown domain: ${domain}`);
        }

        const result = await settingsService.updateDomainSettings(
          domain,
          validatedData,
          ctx.userId,
          'manual'
        );

        // Revalidate relevant pages
        revalidatePath('/admin/settings');
        revalidatePath('/admin/dashboard');

        return result;
      } catch (error) {
        if (error instanceof z.ZodError) {
          const errorMessages = error.errors.map(err => 
            `${err.path.join('.')}: ${err.message}`
          ).join(', ');
          
          throw new TRPCError({
            code: 'BAD_REQUEST',
            message: `Validation error: ${errorMessages}`,
            cause: error,
          });
        }
        
        logger.error('Error updating settings:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to update settings',
          cause: error,
        });
      }
    }),

  // Domain-specific update endpoints (for backward compatibility)
  updateGeneralSettings: adminProcedure
    .input(generalSettingsSchema)
    .mutation(async ({ input, ctx }) => {
      if (!ctx.userId) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: 'User ID is required for this operation',
        });
      }
      const transformedData = transformToGeneralSettings(input);
      return settingsService.updateDomainSettings('general', transformedData, ctx.userId, 'manual');
    }),

  updateBookingSettings: adminProcedure
    .input(bookingSettingsSchema)
    .mutation(async ({ input, ctx }) => {
      if (!ctx.userId) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: 'User ID is required for this operation',
        });
      }
      const transformedData = transformToBookingSettings(input);
      return settingsService.updateDomainSettings('booking', transformedData, ctx.userId, 'manual');
    }),

  updateEmailSettings: adminProcedure
    .input(emailSettingsSchema)
    .mutation(async ({ input, ctx }) => {
      if (!ctx.userId) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: 'User ID is required for this operation',
        });
      }
      const transformedData = transformToEmailSettings(input);
      return settingsService.updateDomainSettings('email', transformedData, ctx.userId, 'manual');
    }),

  updateSecuritySettings: adminProcedure
    .input(securitySettingsSchema)
    .mutation(async ({ input, ctx }) => {
      if (!ctx.userId) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: 'User ID is required for this operation',
        });
      }
      const transformedData = transformToSecuritySettings(input);
      return settingsService.updateDomainSettings('security', transformedData, ctx.userId, 'manual');
    }),

  updateNotificationSettings: adminProcedure
    .input(notificationSettingsSchema)
    .mutation(async ({ input, ctx }) => {
      if (!ctx.userId) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: 'User ID is required for this operation',
        });
      }
      const transformedData = transformToNotificationSettings(input);
      return settingsService.updateDomainSettings('notifications', transformedData, ctx.userId, 'manual');
    }),

  // Send test email
  sendTestEmail: adminProcedure
    .input(testEmailSchema)
    .mutation(async ({ input, ctx }) => {
      try {
        const settings = await settingsService.getSettings();
        const emailSettings = settings.email;

        // Create test email content based on template
        const { subject, htmlContent, textContent } = generateTestEmailContent(
          input.template, 
          input.email, 
          { general: settings.general }
        );

        const result = await sendEmail({
          to: input.email,
          subject,
          html: htmlContent,
          text: textContent,
          from: emailSettings.fromName ? 
                `${emailSettings.fromName} <${emailSettings.fromEmail}>` : 
                emailSettings.fromEmail
        });

        if (result.success) {
          logger.info('Test email sent successfully:', {
            userId: ctx.userId,
            recipient: input.email,
            template: input.template
          });

          return { 
            success: true, 
            message: 'Test email sent successfully',
            details: {
              recipient: input.email,
              subject,
              template: input.template,
              sentAt: new Date().toISOString(),
              emailProvider: emailSettings.emailProvider
            }
          };
        } else {
          const errorMessage = result.error instanceof Error 
            ? result.error.message 
            : typeof result.error === 'string' 
              ? result.error 
              : 'Failed to send email';
          throw new Error(errorMessage);
        }
      } catch (error) {
        logger.error('Error sending test email:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error instanceof Error ? error.message : 'Failed to send test email',
          cause: error,
        });
      }
    }),

  // Settings management
  createBackup: adminProcedure
    .input(z.object({
      name: z.string().min(1, 'Backup name is required'),
      description: z.string().optional()
    }))
    .mutation(async ({ input, ctx }) => {
      try {
        if (!ctx.userId) {
          throw new TRPCError({
            code: 'UNAUTHORIZED',
            message: 'User ID is required for this operation',
          });
        }

        const backupId = await settingsService.createBackup(
          input.name,
          input.description ?? null,
          ctx.userId
        );

        return {
          success: true,
          message: 'Settings backup created successfully',
          backupId
        };
      } catch (error) {
        logger.error('Error creating settings backup:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to create settings backup',
          cause: error,
        });
      }
    }),

  restoreBackup: adminProcedure
    .input(z.object({
      backupId: z.string(),
      confirmRestore: z.boolean()
    }))
    .mutation(async ({ input, ctx }) => {
      if (!input.confirmRestore) {
        throw new TRPCError({
          code: 'PRECONDITION_FAILED',
          message: 'Restore confirmation required',
        });
      }

      try {
        if (!ctx.userId) {
          throw new TRPCError({
            code: 'UNAUTHORIZED',
            message: 'User ID is required for this operation',
          });
        }

        await settingsService.restoreFromBackup(input.backupId, ctx.userId);

        // Revalidate all settings-related pages
        revalidatePath('/admin/settings');
        revalidatePath('/admin/dashboard');

        return {
          success: true,
          message: 'Settings restored successfully from backup'
        };
      } catch (error) {
        logger.error('Error restoring settings backup:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to restore settings from backup',
          cause: error,
        });
      }
    }),

  resetToDefaults: adminProcedure
    .input(z.object({
      domains: z.array(z.enum(['general', 'booking', 'email', 'security', 'notifications'])),
      confirmReset: z.boolean()
    }))
    .mutation(async ({ input, ctx }) => {
      if (!input.confirmReset) {
        throw new TRPCError({
          code: 'PRECONDITION_FAILED',
          message: 'Reset confirmation required',
        });
}

      try {
        if (!ctx.userId) {
          throw new TRPCError({
            code: 'UNAUTHORIZED',
            message: 'User ID is required for this operation',
          });
        }

        await settingsService.resetToDefaults(input.domains, ctx.userId);

        revalidatePath('/admin/settings');
        revalidatePath('/admin/dashboard');

        return {
          success: true,
          message: `Reset ${input.domains.length} setting domains to defaults`
        };
      } catch (error) {
        logger.error('Error resetting settings:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to reset settings to defaults',
          cause: error,
        });
      }
    }),

  getSettingsHistory: adminProcedure
    .input(z.object({
      domain: z.enum(['general', 'booking', 'email', 'security', 'notifications']).optional(),
      limit: z.number().min(1).max(100).default(50)
    }))
    .query(async ({ input }) => {
      try {
        return await settingsService.getSettingsHistory(input.domain, input.limit);
      } catch (error) {
        logger.error('Error fetching settings history:', error);
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Failed to fetch settings history',
          cause: error,
        });
}
    }),

  // Simplified system operations
  clearCache: adminProcedure.mutation(async ({ ctx }) => {
    try {
      if (!ctx.userId) {
        throw new TRPCError({
          code: 'UNAUTHORIZED',
          message: 'User ID is required for this operation',
        });
}      const criticalPaths = [
        '/admin/settings', '/admin/dashboard', '/'
];


      criticalPaths.forEach(path => {
        try {
          revalidatePath(path);
        } catch (error) {
          logger.warn(`Failed to revalidate path ${path}:`, error);
        }
      });

      logger.info('Cache cleared successfully:', {
        userId: ctx.userId,
        timestamp: new Date().toISOString()
      });

      return { 
        success: true, 
        message: 'Cache cleared successfully',
        details: {
          pathsCleared: criticalPaths.length,
          timestamp: new Date().toISOString()
        }
      };
    } catch (error) {
      logger.error('Cache clearing operation failed:', error);
      throw new TRPCError({
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Failed to clear cache',
        cause: error,
      });
    }
  }),
});

/**
 * Helper function to generate test email content
 */
function generateTestEmailContent(
  template: string, 
  email: string, 
  settings: { general: { siteName?: string } }
): { subject: string; htmlContent: string; textContent: string } {
  const siteName = settings.general.siteName ?? 'Ink 37 Tattoos';

  switch (template) {
    case 'booking':
      return {
        subject: `Test: Booking Confirmation - ${siteName}`,
        htmlContent: `
          <h2>Booking Confirmation Test</h2>
          <p>This is a test booking confirmation email from ${siteName}.</p>
          <p>Test sent to: ${email}</p>
        `,
        textContent: `Booking Confirmation Test\n\nThis is a test booking confirmation email from ${siteName}.\nTest sent to: ${email}`
      };
    case 'payment':
      return {
        subject: `Test: Payment Confirmation - ${siteName}`,
        htmlContent: `
          <h2>Payment Confirmation Test</h2>
          <p>This is a test payment confirmation email from ${siteName}.</p>
          <p>Test sent to: ${email}</p>
        `,
        textContent: `Payment Confirmation Test\n\nThis is a test payment confirmation email from ${siteName}.\nTest sent to: ${email}`
      };
    case 'welcome':
      return {
        subject: `Test: Welcome to ${siteName}`,
        htmlContent: `
          <h2>Welcome Test</h2>
          <p>This is a test welcome email from ${siteName}.</p>
          <p>Test sent to: ${email}</p>
        `,
        textContent: `Welcome Test\n\nThis is a test welcome email from ${siteName}.\nTest sent to: ${email}`
      };
    default:
      return {
        subject: `Test Email from ${siteName}`,
        htmlContent: `
          <h2>Test Email</h2>
          <p>This is a test email from ${siteName}.</p>
          <p>If you received this, your email configuration is working correctly.</p>
          <p>Test sent to: ${email}</p>
          <p>Timestamp: ${new Date().toISOString()}</p>
        `,
        textContent: `Test Email\n\nThis is a test email from ${siteName}.\nIf you received this, your email configuration is working correctly.\nTest sent to: ${email}\nTimestamp: ${new Date().toISOString()}`
      };
  }
}
/**
 * tRPC Procedures
 *
 * This file contains procedures for server-only usage.
 * Should not be imported by client components.
 */

import { initTRPC, TRPCError } from '@trpc/server';
import superjson from 'superjson';
import { logger } from '@/lib/logger';
import type { TRPCContext } from './context';

// Initialize tRPC with context
const t = initTRPC.context<TRPCContext>().create({
  transformer: superjson,
  errorFormatter: ({ shape, error }) => ({
    ...shape,
    data: {
      ...shape.data,
      zodError: error.cause instanceof Error ? error.cause : null,
    },
  }),
});

// Export reusable router and procedure helpers
export const router = t.router;
export const middleware = t.middleware;

// Create auth middleware for Better Auth
const authMiddleware = middleware(async ({ ctx, next }) => {
  if (!ctx.userId) {
    void logger.debug('Auth middleware: No userId found', {
      userId: ctx.userId,
      hasUser: !!ctx.user,
      userEmail: ctx.userEmail,
    });
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'You must be logged in to access this resource',
    });
  }

  void logger.debug('Auth middleware: User authenticated', {
    userId: ctx.userId,
    userEmail: ctx.userEmail,
  });

  return next({
    ctx: {
      ...ctx,
      userId: ctx.userId,
      user: ctx.user, // Better Auth session user
      userEmail: ctx.userEmail, // User email
      db: ctx.prisma, // Ensure prisma is passed
    },
  });
});

// Create logger middleware
const loggerMiddleware = middleware(async ({ path, next, type }) => {
  const start = Date.now();

  const result = await next();

  const duration = Date.now() - start;
  void logger.info(`[tRPC] ${type} ${path} - ${duration}ms`);

  return result;
});

// Public procedure - accessible without authentication
export const publicProcedure = t.procedure.use(loggerMiddleware).use(
  middleware(async ({ ctx, next }) => {
    return next({
      ctx: {
        ...ctx,
        db: ctx.prisma, // Ensure prisma is passed
      },
    });
  })
);

// Protected procedure - requires authentication
export const protectedProcedure = t.procedure.use(loggerMiddleware).use(authMiddleware);

// Admin role middleware - checks if the user has admin role
const adminMiddleware = middleware(async ({ ctx, next }) => {
  // First ensure user is authenticated
  if (!ctx.userId || !ctx.user) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'You must be logged in to access this resource',
    });
  }
  
  // Then check if user has admin role
  // This assumes user object has a role property - adjust based on your auth implementation
  const hasAdminRole = ctx.user.role === 'admin';
  
  if (!hasAdminRole) {
    void logger.warn('Admin access attempt denied', {
      userId: ctx.userId,
      userEmail: ctx.userEmail,
      action: 'admin_access_denied',
    });
    
    throw new TRPCError({
      code: 'FORBIDDEN',
      message: 'You do not have permission to access this resource',
    });
  }
  
  void logger.debug('Admin access granted', {
    userId: ctx.userId,
    userEmail: ctx.userEmail,
  });
  
  return next({
    ctx: {
      ...ctx,
      isAdmin: true,
    },
  });
});

// Admin procedure - requires admin role
export const adminProcedure = t.procedure
  .use(loggerMiddleware)
  .use(authMiddleware)
  .use(adminMiddleware);/**
 * TRPC Context Creation with Better Auth Authentication
 *
 * This file handles the creation of context for TRPC procedures.
 * The context includes access to the database via Prisma and user auth via Better Auth.
 *
 * THIS IS A SERVER-SIDE ONLY FILE
 */
import 'server-only';
import { NextRequest } from 'next/server';
import { auth } from '@/lib/auth';
import { prisma } from '@/lib/db/prisma';
import { logger } from '@/lib/logger';
import type { PrismaClient } from '@prisma/client';

/**
 * Session user type from Better Auth
 */
interface SessionUser {
  id: string;
  email: string;
  name?: string | null;
  image?: string | null | undefined;
  role?: string;
}

/**
 * Base tRPC context interface
 */
export interface TRPCContext {
  req?: NextRequest;
  resHeaders?: Headers;
  headers?: Record<string, string>;
  prisma: PrismaClient;
  user: SessionUser | null; // Better Auth session user
  userId: string | null;
  userEmail: string | null;
  url?: string;
  db: PrismaClient; // Alias for prisma
}

/**
 * Authenticated context - user is guaranteed to exist
 */
export interface AuthenticatedTRPCContext extends TRPCContext {
  userId: string;
  user: SessionUser;
  userEmail: string;
  isAdmin?: boolean;
}

/**
 * Creates context for TRPC API route handlers
 */
export async function createTRPCContext({
  req,
  resHeaders,
}: {
  req: NextRequest;
  resHeaders: Headers;
}) {
  try {
    // Get Better Auth session
    const session = await auth.api.getSession({ req });
    const user = session?.user ?? null;

    // Get request headers
    const requestHeaders = Object.fromEntries(req.headers.entries());

    // Log URL for debugging
    const url = req.url ?? '';
    const referer = req.headers.get('referer') ?? '';

    // Use our universal logger
    void logger.debug('Creating tRPC context', {
      url,
      referer,
      userId: user?.id,
      userEmail: user?.email,
      authError: user ? null : 'Auth session missing!',
    });

    // Return the context with database access and auth
    return {
      req,
      resHeaders,
      headers: requestHeaders,
      prisma,
      user, // Better Auth session user
      userId: user?.id ?? null, // Direct access to user ID
      userEmail: user?.email ?? null, // Direct access to user email
      url,
      db: prisma, // Add db alias for compatibility
    };
  } catch (error) {
    void logger.error('Error creating TRPC context:', error);

    // Return a basic context even if there's an error
    return {
      req,
      resHeaders,
      headers: Object.fromEntries(req.headers.entries()),
      prisma,
      user: null,
      userId: null,
      userEmail: null,
      url: '',
      db: prisma, // Add db alias for compatibility
    };
  }
}

/**
 * Exported Context type for use in tRPC initialization
 */
export type Context = TRPCContext;

/**
 * Creates context for React Server Components and Server Actions
 * This is used for direct tRPC procedure calls from the server
 * without going through the HTTP API layer
 */
export async function createContextForRSC() {
  try {
    // Get Better Auth session for RSC
    const session = await auth.api.getSession();
    const user = session?.user ?? null;

    void logger.debug('Creating RSC tRPC context', {
      userId: user?.id,
      userEmail: user?.email,
      authError: user ? null : 'Auth session missing!',
    });

    return {
      prisma,
      user, // Better Auth session user
      userId: user?.id ?? null, // Direct access to user ID
      userEmail: user?.email ?? null, // Direct access to user email
      db: prisma, // Add db alias for consistency
    };
  } catch (error) {
    void logger.error('Error creating RSC context:', error);

    return {
      prisma,
      user: null,
      userId: null,
      userEmail: null,
      db: prisma,
    };
  }
}/**
 * tRPC Utility Functions
 * 
 * This file contains utility functions for tRPC that can be safely
 * imported from both client and server components without circular dependencies.
 */

/**
 * Helper function to get the base URL for API calls
 * This function works in both browser and server environments
 */
export function getBaseUrl() {
  if (typeof window !== 'undefined') {
    return process.env.NODE_ENV === "production" 
      ? "https://ink37tattoos.com" 
      : window.location.origin;
  }
  // In server environment
  if (process.env["VERCEL_URL"]) return `https://${process.env["VERCEL_URL"]}`;
  return process.env.NODE_ENV === "production"
    ? "https://ink37tattoos.com"
    : `http://localhost:${process.env["PORT"] ?? '3000'}`;
}
/**
 * Error Handler Utility
 * 
 * Provides standardized error handling for tRPC procedures.
 * Ensures consistent error formatting, logging, and error codes.
 */
import { TRPCError } from '@trpc/server';
import { Prisma } from '@prisma/client';
import { logger } from '@/lib/logger';
// Validation error type for form/API validation
type ValidationError = {
  field: string;
  message: string;
  code?: string;
};

/**
 * Handles various error types and standardizes them into TRPCErrors
 * with appropriate error codes and logging
 * 
 * @param error The error to handle
 * @param context Additional context information for logging
 * @param message Optional custom error message
 * @returns Never - always throws a TRPCError
 */
export function handleError(
  error: unknown, 
  context: Record<string, unknown> = {}, 
  message = 'An error occurred during the operation'
): never {
  // If it's already a TRPCError, just pass it through with logging
  if (error instanceof TRPCError) {
    void logger.error(`TRPC Error (${error.code}): ${error.message}`, {
      ...context,
      errorType: 'TRPCError',
      trpcCode: error.code,
    });
    throw error;
  }

  // Handle Prisma-specific errors with appropriate codes
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    const errorCode = getPrismaErrorCode(error.code);
    const errorMessage = getPrismaErrorMessage(error.code, message);

    void logger.error(`Prisma Error (${error.code}): ${errorMessage}`, {
      ...context,
      errorType: 'PrismaError',
      prismaCode: error.code,
      target: error.meta?.['target'],
    });

    throw new TRPCError({
      code: errorCode,
      message: errorMessage,
      cause: error,
    });
  }

  // Handle other error types
  const errorMessage = error instanceof Error ? error.message : String(error);
  
  void logger.error(`Unexpected Error: ${errorMessage}`, {
    ...context,
    errorType: error instanceof Error ? error.constructor.name : typeof error,
    stack: error instanceof Error ? error.stack : undefined,
  });

  throw new TRPCError({
    code: 'INTERNAL_SERVER_ERROR',
    message,
    cause: error,
  });
}

/**
 * Maps Prisma error codes to appropriate TRPC error codes
 */
function getPrismaErrorCode(prismaCode: string): TRPCError['code'] {
  switch (prismaCode) {
    case 'P2002': // Unique constraint violation
      return 'CONFLICT';
    case 'P2003': // Foreign key constraint violation
      return 'BAD_REQUEST';
    case 'P2025': // Record not found
      return 'NOT_FOUND';
    default:
      return 'INTERNAL_SERVER_ERROR';
  }
}

/**
 * Provides user-friendly error messages for common Prisma errors
 */
function getPrismaErrorMessage(prismaCode: string, defaultMessage: string): string {
  switch (prismaCode) {
    case 'P2002':
      return 'A record with this identifier already exists';
    case 'P2003':
      return 'The operation failed because of a reference constraint';
    case 'P2025':
      return 'The requested record was not found';
    default:
      return defaultMessage;
  }
}

/**
 * Formats validation errors from Zod
 * @param error Zod validation error
 * @returns Formatted error message
 */
export function formatValidationErrors(error: unknown): string {
  if (!error || typeof error !== 'object' || !('errors' in error)) return 'Validation failed';
  
  const errorObj = error as { errors: ValidationError[] };
  return errorObj.errors
    .map((err) => `${err.path}: ${err.message}`)
    .join(', ');
}/**
 * Safe Zod Utilities
 *
 * This file provides safe alternatives to Zod functionality that
 * may cause issues during build or in the Edge runtime.
 */

import * as z from 'zod';

// Check if we're in production build mode
const IS_PRODUCTION = process.env.NODE_ENV === 'production';

/**
 * Creates a safe array validator that works in both development
 * and production environments without causing build issues.
 *
 * @param schema The schema for array elements
 * @returns A Zod schema that safely validates arrays
 */
export function safeArray<T extends z.ZodTypeAny>(schema: T): z.ZodTypeAny {
  if (IS_PRODUCTION) {
    // In production, use a simplified validator that just checks if it's an array
    return z.preprocess(
      (val) => (Array.isArray(val) ? val : typeof val === 'string' ? [val] : []),
      z.unknown()
    );
  }

  // In development, use the full Zod validation
  return z.array(schema);
}

/**
 * Export Zod namespace for convenience
 */
export { z };
/**
 * Router Error Handler
 * 
 * Standardized error handling for tRPC routers
 */
import { TRPCError } from '@trpc/server';
import { logger } from '@/lib/logger';
import { Prisma } from '@prisma/client';

export type RouterErrorContext = {
  operation: string;
  procedureName: string;
  routerName: string;
  userId?: string;
  input?: unknown;
};

/**
 * Handles errors in tRPC router procedures with consistent error types and logging
 */
export function handleRouterError(
  error: unknown, 
  context: RouterErrorContext
): never {
  // Extract context information for better error logging
  const { operation, procedureName, routerName, userId, input } = context;
  
  // Log the error with context
  void logger.error(`${routerName}.${procedureName} error (${operation})`, {
    error,
    userId,
    input: input ? JSON.stringify(input).substring(0, 500) : undefined,
  });
  
  // Handle Prisma errors
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    switch (error.code) {
      case 'P2025': // Record not found
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'The requested resource was not found',
          cause: error,
        });
      case 'P2002': // Unique constraint failed
        throw new TRPCError({
          code: 'CONFLICT',
          message: 'A resource with this identifier already exists',
          cause: error,
        });
      case 'P2003': // Foreign key constraint failed
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Invalid reference to a related resource',
          cause: error,
        });
      case 'P2004': // Constraint violation
      case 'P2005': // Invalid value
      case 'P2006': // Invalid value for type
      case 'P2007': // Validation error
      case 'P2008': // Query parsing error
      case 'P2009': // Query validation error
      case 'P2010': // Raw query error
      case 'P2011': // Null constraint violation
      case 'P2012': // Missing required value
      case 'P2013': // Missing required argument
      case 'P2014': // Relation violation
      case 'P2015': // Related record not found
      case 'P2016': // Query interpretation error
      case 'P2017': // Relation records not connected
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: error.message,
          cause: error,
        });
      case 'P2018': // Connection error
      case 'P2024': // Timeout error
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'Database connection error',
          cause: error,
        });
      case 'P2019': // Input error
      case 'P2020': // Invalid value for unique field
      case 'P2021': // Table does not exist
      case 'P2022': // Column does not exist
      case 'P2023': // Inconsistent column data
      default:
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: 'An unexpected database error occurred',
          cause: error,
        });
    }
  }
  
  // Handle tRPC errors - pass through
  if (error instanceof TRPCError) {
    throw error;
  }
  
  // Handle standard errors
  if (error instanceof Error) {
    // If error.name contains specific error indicators, map to appropriate TRPC errors
    const errorName = error.name.toLowerCase();
    
    if (errorName.includes('auth') || errorName.includes('unauthorized') || errorName.includes('unauthenticated')) {
      throw new TRPCError({
        code: 'UNAUTHORIZED',
        message: error.message || 'Authentication required',
        cause: error,
      });
    }
    
    if (errorName.includes('forbidden') || errorName.includes('permission')) {
      throw new TRPCError({
        code: 'FORBIDDEN',
        message: error.message || 'Insufficient permissions',
        cause: error,
      });
    }
    
    if (errorName.includes('not found') || errorName.includes('notfound') || errorName.includes('404')) {
      throw new TRPCError({
        code: 'NOT_FOUND',
        message: error.message || 'Resource not found',
        cause: error,
      });
    }
    
    if (errorName.includes('validation') || 
        errorName.includes('invalid') || 
        errorName.includes('typeerror') ||
        errorName.includes('syntaxerror')) {
      throw new TRPCError({
        code: 'BAD_REQUEST',
        message: error.message || 'Invalid input',
        cause: error,
      });
    }
    
    if (errorName.includes('timeout') || errorName.includes('deadline')) {
      throw new TRPCError({
        code: 'TIMEOUT',
        message: error.message || 'Operation timed out',
        cause: error,
      });
    }
    
    // Default error handling
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: error.message || 'An unexpected error occurred',
      cause: error,
    });
  }
  
  // Handle unknown errors
  throw new TRPCError({
    code: 'INTERNAL_SERVER_ERROR',
    message: 'An unexpected error occurred',
    cause: error,
  });
}/**
 * tRPC API Router (CLIENT-SAFE VERSION)
 * 
 * IMPORTANT: This file exists to provide a safe way for client components
 * to import the AppRouter type without importing server-only code.
 * 
 * Why this exists:
 * 1. app-router.ts has the 'server-only' directive and cannot be imported in client components
 * 2. We need the AppRouter type in client components for tRPC type safety
 * 3. This file provides just the type definition without the server code
 * 
 * If you're working on server components, you can import from app-router.ts directly.
 * Client components should import the AppRouter type from here or from client-types.ts.
 */

// Export type definition for client usage
import type { AppRouter as RouterType } from './app-router';
export type AppRouter = RouterType;
/**
 * tRPC Client Provider
 *
 * This file provides the React provider for tRPC client-side hooks.
 * It integrates with React Query and sets up the tRPC client.
 * 
 * IMPORTANT: This file imports the tRPC client from client.ts,
 * which is the single source of truth for tRPC client creation.
 */
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpLink } from '@trpc/client';
import { useState } from 'react';
import superjson from 'superjson';
import { trpc } from './client';
import { getBaseUrl } from './utils';

// Cache times (in milliseconds)
const FIVE_MINUTES = 1000 * 60 * 5;

// TRPCProvider component to wrap your application
export function TRPCProvider({
  children,
  cookies,
  headers = {},
}: {
  children: React.ReactNode;
  cookies?: Record<string, string>;
  headers?: Record<string, string>;
}) {
  const [queryClient] = useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: FIVE_MINUTES,
            refetchOnWindowFocus: false,
            refetchOnReconnect: true,
            retry: 1,
            gcTime: FIVE_MINUTES,
          },
          mutations: {
            retry: 1,
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
          },
        },
      })
  );

  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: [
        httpLink({
          url: `${getBaseUrl()}/api/trpc`,
          headers() {
            return {
              ...headers,
              ...Object.fromEntries(
                Object.entries(cookies ?? {}).map(([key, value]) => [`cookie-${key}`, value])
              ),
            };
          },
          transformer: superjson,
        }),
      ],
    })
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
    </trpc.Provider>
  );
}
/**
 * tRPC Client
 * 
 * This file creates and exports the tRPC client for use in React components.
 * It imports the AppRouter type from api-router.ts, which is the client-safe
 * version that doesn't trigger server-only module errors.
 * 
 * For all tRPC-related types, import from '@/types/trpc-types.ts'
 * 
 * IMPORTANT: This is the single source of truth for tRPC client creation.
 * The client provider (client-provider.tsx) imports from this file.
 */
import { httpLink, createTRPCClient } from '@trpc/client';
import { createTRPCReact } from '@trpc/react-query';
import superjson from 'superjson';
import type { AppRouter } from './api-router';
import { getBaseUrl } from './utils';

// Create the tRPC React client with full type safety
export const trpc = createTRPCReact<AppRouter>();
export const api = trpc; // Export alias for compatibility

// Re-export getBaseUrl for backwards compatibility
export { getBaseUrl } from './utils';

// Create a client for direct use (outside of React components)
export function createTRPCClientInstance() {
  return createTRPCClient<AppRouter>({
    links: [
      httpLink({
        url: `${getBaseUrl()}/api/trpc`,
        transformer: superjson,
      }),
    ],
  });
}
/**
 * tRPC App Router
 *
 * This file combines all the feature-specific routers into a single app router.
 * It serves as the main entry point for all tRPC procedures.
 *
 * THIS IS A SERVER-SIDE ONLY FILE
 */
import 'server-only';
import { router } from './procedures';

import { galleryRouter } from './routers/gallery-router';
// Import the modularized admin router
import { adminMainRouter } from './routers/admin/main-router';
import { subscriptionRouter } from './routers/subscription-router';
import { calRouter } from './routers/cal-router';
import { calAnalyticsRouter } from './routers/cal-analytics-router';
import { dashboardRouter } from './routers/dashboard-router';
import { appointmentsRouter } from './routers/appointments-router';
import { paymentsRouter } from './routers/payments-router';
import { settingsRouter } from './routers/settings-router';

/**
 * Main application router
 *
 * This combines all sub-routers to create the main API
 * entry point. Each sub-router handles a specific feature area.
 */
export const appRouter = router({
  gallery: galleryRouter,
  admin: adminMainRouter,
  subscription: subscriptionRouter,
  cal: calRouter,
  calAnalytics: calAnalyticsRouter,
  dashboard: dashboardRouter,
  appointments: appointmentsRouter,
  payments: paymentsRouter,
  settings: settingsRouter,
});

// Export type definition of the API
export type AppRouter = typeof appRouter;
/**
 * tRPC Server Actions
 *
 * This file provides utilities for using tRPC procedures in Server Actions and
 * Server Components. It allows for type-safe API calls directly from the server.
 * 
 * IMPORTANT: All types have been moved to '@/types/trpc-types.ts'
 * Import types from there instead of from this file.
 */
import 'server-only';
import { appRouter } from './app-router';
import { createContextForRSC } from './context';
import { TRPCError } from '@trpc/server';
import { logger } from '@/lib/logger';
/**
 * Type-safe caller for server components
 * This allows you to call tRPC procedures directly from server components
 * without going through the HTTP API layer.
 */
export async function serverTRPC() {
  try {
    // For server components, we can directly use the createContextForRSC function
    // which provides the necessary context for tRPC procedures without requiring a request
    const ctx = await createContextForRSC();
    
    // Create and return the tRPC caller
    // No need to mock requests - we're directly calling the procedures
    return appRouter.createCaller(ctx);
  } catch (error) {
    // Log the error using the unified logger
    void logger.error('Error creating serverTRPC caller', error);
    
    // Rethrow as tRPC error for consistent error handling
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'Failed to create serverTRPC caller',
      cause: error,
    });
  }
}

/**
 * Type-safe helper to access a procedure dynamically
 */
export function getCallerProcedure<TInput, TOutput>(
  caller: ReturnType<typeof appRouter.createCaller>,
  namespace: string,
  procedure: string
): (input: TInput) => Promise<TOutput> {
  if (!caller[namespace as keyof typeof caller]) {
    throw new TRPCError({
      code: 'BAD_REQUEST',
      message: `Router "${namespace}" not found in caller`,
    });
  }

  const routerCaller = caller[namespace as keyof typeof caller];
  if (typeof routerCaller !== 'object' || routerCaller === null) {
    throw new TRPCError({
      code: 'BAD_REQUEST',
      message: `Router "${namespace}" is not an object`,
    });
  }

  const procedureCaller = routerCaller[procedure as keyof typeof routerCaller];
  if (typeof procedureCaller !== 'function') {
    throw new TRPCError({
      code: 'BAD_REQUEST',
      message: `Procedure "${procedure}" not found in router "${namespace}"`,
    });
  }

  return procedureCaller as (input: TInput) => Promise<TOutput>;
}

/**
 * Type-safe helper for prefetching queries in server components
 * This can be used to prefetch data on the server and hydrate the client
 */
export async function prefetchTRPCQuery<TInput, TOutput>(
  path: string,
  input: TInput
): Promise<TOutput> {
  try {
    const caller = await serverTRPC();
    const splitPath = path.split('.');

    if (splitPath.length !== 2) {
      throw new TRPCError({
        code: 'BAD_REQUEST',
        message: `Invalid tRPC path: ${path}. Expected format: "router.procedure"`,
      });
    }

    const [namespace, procedure] = splitPath;
    // Make sure namespace and procedure are both strings and not null
    if (!namespace || !procedure) {
      throw new TRPCError({
        code: 'BAD_REQUEST',
        message: `Invalid tRPC path segments: ${path}. Expected format: "router.procedure"`,
      });
    }

    return getCallerProcedure<TInput, TOutput>(caller, namespace, procedure)(input);
  } catch (error) {
    // Use detailed logging with structured data
    const inputSafe = JSON.stringify(input).substring(0, 200); // Truncate for safety
    void logger.error(`Error prefetching tRPC query (${path})`, {
      error,
      path,
      inputPreview: inputSafe,
      errorType: error instanceof Error ? error.constructor.name : typeof error,
    });

    // Preserve original tRPC errors
    if (error instanceof TRPCError) {
      throw error;
    }

    // Convert other errors to standard tRPC error format
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: `Failed to prefetch tRPC query: ${path}`,
      cause: error,
    });
  }
}

/**
 * Execute a server mutation from a server component
 * This allows executing mutations with proper error handling
 */
export async function executeServerMutation<TInput, TOutput>(
  path: string,
  input: TInput
): Promise<TOutput> {
  try {
    return await prefetchTRPCQuery<TInput, TOutput>(path, input);
  } catch (error) {
    // Use detailed logging with structured data
    const inputSafe = JSON.stringify(input).substring(0, 200); // Truncate for safety
    void logger.error(`Error executing server mutation (${path})`, {
      error,
      path,
      inputPreview: inputSafe,
      errorType: error instanceof Error ? error.constructor.name : typeof error,
      stack: error instanceof Error ? error.stack : undefined,
    });

    // Preserve original tRPC errors
    if (error instanceof TRPCError) {
      throw error;
    }

    // Convert other errors to standard tRPC error format with improved detail
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: `Failed to execute server mutation: ${path}`,
      cause: error,
    });
  }
}
